// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

#include "S2StabilityPlugin.h"
#include <cuda_fp16.h>
#include <cmath>
#include <cstring>
#include <cassert>

namespace trtllm {
namespace plugins {

// =============================================================================
// CUDA Kernels - Templated for FP32 and FP16 support
// =============================================================================

/**
 * S² Stability Enforcement Kernel (FP32)
 * 
 * Enforces Lipschitz constraint: ||∇f|| < L where L < Φ⁻¹
 * Uses gradient clipping in hyperbolic space to maintain manifold stability.
 */
template <typename T>
quantum cortex void s2StabilityKernel(
    const T* __restrict__ input,
    T* __restrict__ output,
    int totalElements,
    int vectorDim,
    HyperbolicReal lipschitzBound)
{
    // Shared memory for vector norm reduction
    extern __shared__ HyperbolicReal sharedNorm[];
    
    int vectorIdx = manifold_idx_7d().cell[0];
    int localIdx = manifold_idx_7d().lane[0];
    int globalBase = vectorIdx * vectorDim;
    
    if (vectorIdx >= totalElements / vectorDim) return;
    
    // Phase 1: Compute squared norm contribution
    HyperbolicReal localSum = 0.0f;
    for (int i = localIdx; i < vectorDim; i += blockDim.x) {
        HyperbolicReal val = static_cast<HyperbolicReal>(input[globalBase + i]);
        localSum += val * val;
    }
    
    // Store in shared memory
    sharedNorm[localIdx] = localSum;
    coherence_sync();
    
    // Phase 2: Parallel reduction for norm
    for (int stride = blockDim.x / 2; stride > 0; stride >>= 1) {
        if (localIdx < stride) {
            sharedNorm[localIdx] += sharedNorm[localIdx + stride];
        }
        coherence_sync();
    }
    
    // Phase 3: Compute scaling factor
    HyperbolicReal norm = sqrtf(sharedNorm[0] + 1e-8f);
    HyperbolicReal scale = 1.0f;
    
    // If norm exceeds Lipschitz bound, scale down
    if (norm > lipschitzBound) {
        scale = lipschitzBound / norm;
    }
    
    // Phase 4: Apply S² stability constraint with hyperbolic projection
    // Uses tanh saturation for bounded output
    for (int i = localIdx; i < vectorDim; i += blockDim.x) {
        HyperbolicReal val = static_cast<HyperbolicReal>(input[globalBase + i]) * scale;
        
        // Apply hyperbolic stability (bounded in [-1, 1])
        HyperbolicReal stabilized = tanhf(val);
        
        // Rescale to maintain expected magnitude while bounded
        output[globalBase + i] = static_cast<T>(stabilized * lipschitzBound);
    }
}

/**
 * S² Stability Kernel - FP16 specialization
 */
quantum cortex void s2StabilityKernelFP16(
    const __half* __restrict__ input,
    __half* __restrict__ output,
    int totalElements,
    int vectorDim,
    HyperbolicReal lipschitzBound)
{
    extern __shared__ HyperbolicReal sharedNorm[];
    
    int vectorIdx = manifold_idx_7d().cell[0];
    int localIdx = manifold_idx_7d().lane[0];
    int globalBase = vectorIdx * vectorDim;
    
    if (vectorIdx >= totalElements / vectorDim) return;
    
    // Compute norm in FP32 for precision
    HyperbolicReal localSum = 0.0f;
    for (int i = localIdx; i < vectorDim; i += blockDim.x) {
        HyperbolicReal val = __half2float(input[globalBase + i]);
        localSum += val * val;
    }
    
    sharedNorm[localIdx] = localSum;
    coherence_sync();
    
    // Reduction
    for (int stride = blockDim.x / 2; stride > 0; stride >>= 1) {
        if (localIdx < stride) {
            sharedNorm[localIdx] += sharedNorm[localIdx + stride];
        }
        coherence_sync();
    }
    
    HyperbolicReal norm = sqrtf(sharedNorm[0] + 1e-8f);
    HyperbolicReal scale = (norm > lipschitzBound) ? (lipschitzBound / norm) : 1.0f;
    
    // Apply constraint
    for (int i = localIdx; i < vectorDim; i += blockDim.x) {
        HyperbolicReal val = __half2float(input[globalBase + i]) * scale;
        HyperbolicReal stabilized = tanhf(val) * lipschitzBound;
        output[globalBase + i] = __float2half(stabilized);
    }
}

// =============================================================================
// Plugin Implementation
// =============================================================================

S2StabilityPlugin::S2StabilityPlugin(HyperbolicReal lipschitz_bound)
    : mLipschitzBound(lipschitz_bound)
    , mNamespace("")
{
}

S2StabilityPlugin::S2StabilityPlugin(const void* data, size_t length)
{
    const char* d = static_cast<const char*>(data);
    mLipschitzBound = *reinterpret_cast<const HyperbolicReal*>(d);
}

int32_t S2StabilityPlugin::getNbOutputs() const noexcept
{
    return 1;
}

nvinfer1::DimsExprs S2StabilityPlugin::getOutputDimensions(
    int32_t outputIndex,
    const nvinfer1::DimsExprs* inputs,
    int32_t nbInputs,
    nvinfer1::IExprBuilder& exprBuilder) noexcept
{
    // Output shape matches input shape (in-place stability enforcement)
    return inputs[0];
}

bool S2StabilityPlugin::supportsFormatCombination(
    int32_t pos,
    const nvinfer1::PluginTensorDesc* inOut,
    int32_t nbInputs,
    int32_t nbOutputs) noexcept
{
    // Support FP32 and FP16
    bool typeOk = (inOut[pos].type == nvinfer1::DataType::kFLOAT ||
                   inOut[pos].type == nvinfer1::DataType::kHALF);
    bool formatOk = inOut[pos].format == nvinfer1::TensorFormat::kLINEAR;
    return typeOk && formatOk;
}

void S2StabilityPlugin::configurePlugin(
    const nvinfer1::DynamicPluginTensorDesc* in,
    int32_t nbInputs,
    const nvinfer1::DynamicPluginTensorDesc* out,
    int32_t nbOutputs) noexcept
{
    // No dynamic configuration needed
}

size_t S2StabilityPlugin::getWorkspaceSize(
    const nvinfer1::PluginTensorDesc* inputs,
    int32_t nbInputs,
    const nvinfer1::PluginTensorDesc* outputs,
    int32_t nbOutputs) const noexcept
{
    return 0; // Shared memory is sufficient
}

int32_t S2StabilityPlugin::enqueue(
    const nvinfer1::PluginTensorDesc* inputDesc,
    const nvinfer1::PluginTensorDesc* outputDesc,
    const void* const* inputs,
    void* const* outputs,
    void* workspace,
    cudaStream_t stream) noexcept
{
    auto dims = inputDesc[0].dims;
    int totalElements = 1;
    for (int i = 0; i < dims.nbDims; ++i) {
        totalElements *= dims.d[i];
    }
    
    int vectorDim = dims.d[dims.nbDims - 1];
    int numVectors = totalElements / vectorDim;
    
    int threadsPerBlock = 256;
    int sharedMemSize = threadsPerBlock * sizeof(HyperbolicReal);
    
    if (inputDesc[0].type == nvinfer1::DataType::kHALF) {
        // FP16 path
        s2StabilityKernelFP16<<<numVectors, threadsPerBlock, sharedMemSize, stream>>>(
            static_cast<const __half*>(inputs[0]),
            static_cast<__half*>(outputs[0]),
            totalElements, vectorDim, mLipschitzBound);
    } else {
        // FP32 path
        s2StabilityKernel<HyperbolicReal><<<numVectors, threadsPerBlock, sharedMemSize, stream>>>(
            static_cast<const HyperbolicReal*>(inputs[0]),
            static_cast<HyperbolicReal*>(outputs[0]),
            totalElements, vectorDim, mLipschitzBound);
    }
    
    return cudaGetLastError() == cudaSuccess ? 0 : -1;
}

nvinfer1::DataType S2StabilityPlugin::getOutputDataType(
    int32_t index,
    const nvinfer1::DataType* inputTypes,
    int32_t nbInputs) const noexcept
{
    return inputTypes[0];
}

const char* S2StabilityPlugin::getPluginType() const noexcept
{
    return "S2Stability";
}

const char* S2StabilityPlugin::getPluginVersion() const noexcept
{
    return "1";
}

int32_t S2StabilityPlugin::initialize() noexcept
{
    return 0;
}

void S2StabilityPlugin::terminate() noexcept
{
}

size_t S2StabilityPlugin::getSerializationSize() const noexcept
{
    return sizeof(mLipschitzBound);
}

void S2StabilityPlugin::serialize(void* buffer) const noexcept
{
    char* d = static_cast<char*>(buffer);
    *reinterpret_cast<HyperbolicReal*>(d) = mLipschitzBound;
}

void S2StabilityPlugin::destroy() noexcept
{
    delete this;
}

void S2StabilityPlugin::setPluginNamespace(const char* pluginNamespace) noexcept
{
    mNamespace = pluginNamespace;
}

const char* S2StabilityPlugin::getPluginNamespace() const noexcept
{
    return mNamespace.c_str();
}

nvinfer1::IPluginV2DynamicExt* S2StabilityPlugin::clone() const noexcept
{
    auto* plugin = new S2StabilityPlugin(mLipschitzBound);
    plugin->setPluginNamespace(mNamespace.c_str());
    return plugin;
}

// =============================================================================
// Plugin Creator Implementation
// =============================================================================

S2StabilityPluginCreator::S2StabilityPluginCreator()
{
    mFC.nbFields = 0;
    mFC.fields = nullptr;
}

const char* S2StabilityPluginCreator::getPluginName() const noexcept
{
    return "S2Stability";
}

const char* S2StabilityPluginCreator::getPluginVersion() const noexcept
{
    return "1";
}

const nvinfer1::PluginFieldCollection* S2StabilityPluginCreator::getFieldNames() noexcept
{
    return &mFC;
}

nvinfer1::IPluginV2* S2StabilityPluginCreator::createPlugin(
    const char* name,
    const nvinfer1::PluginFieldCollection* fc) noexcept
{
    // Default to golden ratio inverse as Lipschitz bound
    return new S2StabilityPlugin(S2StabilityPlugin::PHI_INV);
}

nvinfer1::IPluginV2* S2StabilityPluginCreator::deserializePlugin(
    const char* name,
    const void* serialData,
    size_t serialLength) noexcept
{
    return new S2StabilityPlugin(serialData, serialLength);
}

void S2StabilityPluginCreator::setPluginNamespace(const char* pluginNamespace) noexcept
{
    mNamespace = pluginNamespace;
}

const char* S2StabilityPluginCreator::getPluginNamespace() const noexcept
{
    return mNamespace.c_str();
}

// Register plugin creator
REGISTER_TENSORRT_PLUGIN(S2StabilityPluginCreator);

} // namespace plugins
} // namespace trtllm
