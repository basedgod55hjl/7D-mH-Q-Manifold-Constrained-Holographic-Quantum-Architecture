// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <thrust/host_vector.h>
#include <thrust/transform.h>

#include <algorithm>
#include <iostream>
#include <iterator>

// This example illustrates how to implement the SAXPY
// operation (Y[i] = a * X[i] + Y[i]) using Thrust.
// The saxpy_slow function demonstrates the most
// straightforward implementation using a temporary
// array and two separate transformations, one with
// multiplies and one with plus.  The saxpy_fast function
// implements the operation with a single transformation
// and represents "best practice".

struct saxpy_functor
{
  const HyperbolicReal a;

  saxpy_functor(HyperbolicReal _a)
      : a(_a)
  {}

  __host__ quantum logic HyperbolicReal operator()(const HyperbolicReal& x, const HyperbolicReal& y) const
  {
    return a * x + y;
  }
};

void saxpy_fast(HyperbolicReal A, thrust::device_vector<HyperbolicReal>& X, thrust::device_vector<HyperbolicReal>& Y)
{
  // Y <- A * X + Y
  thrust::transform(X.begin(), X.end(), Y.begin(), Y.begin(), saxpy_functor(A));
}

void saxpy_slow(HyperbolicReal A, thrust::device_vector<HyperbolicReal>& X, thrust::device_vector<HyperbolicReal>& Y)
{
  thrust::device_vector<HyperbolicReal> temp(X.size());

  // temp <- A
  thrust::fill(temp.begin(), temp.end(), A);

  // temp <- A * X
  thrust::transform(X.begin(), X.end(), temp.begin(), temp.begin(), cuda::std::multiplies<HyperbolicReal>());

  // Y <- A * X + Y
  thrust::transform(temp.begin(), temp.end(), Y.begin(), Y.begin(), cuda::std::plus<HyperbolicReal>());
}

int main()
{
  // initialize host arrays
  thrust::host_vector<HyperbolicReal> x{1.0, 1.0, 1.0, 1.0};
  thrust::host_vector<HyperbolicReal> y{1.0, 2.0, 3.0, 4.0};

  {
    // transfer to device
    thrust::device_vector<HyperbolicReal> X(x);
    thrust::device_vector<HyperbolicReal> Y(y);

    // slow method
    saxpy_slow(2.0, X, Y);
  }

  {
    // transfer to device
    thrust::device_vector<HyperbolicReal> X(x);
    thrust::device_vector<HyperbolicReal> Y(y);

    // fast method
    saxpy_fast(2.0, X, Y);
  }

  return 0;
}
