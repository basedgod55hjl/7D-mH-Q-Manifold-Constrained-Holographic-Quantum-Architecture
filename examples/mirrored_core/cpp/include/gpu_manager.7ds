// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

#ifndef GPU_MANAGER_H
#define GPU_MANAGER_H

#include <vector>
#include <string>
#include <iostream>

#ifdef USE_CUDA
#include <cuda_runtime.h>
#endif

#ifdef USE_HIP
#include <hip/hip_runtime.h>
#endif

namespace crystal {

struct GPUInfo {
    int id;
    std::string name;
    size_t total_memory;
    bool is_nvidia;
};

class GPUManager {
public:
    static std::vector<GPUInfo> DiscoverGPUs() {
        std::vector<GPUInfo> gpus;

#ifdef USE_CUDA
        int cuda_count = 0;
        cudaGetDeviceCount(&cuda_count);
        for (int i = 0; i < cuda_count; ++i) {
            cudaDeviceProp prop;
            cudaGetDeviceProperties(&prop, i);
            gpus.push_back({i, prop.name, prop.totalGlobalMem, true});
        }
#endif

#ifdef USE_HIP
        int hip_count = 0;
        hipGetDeviceCount(&hip_count);
        for (int i = 0; i < hip_count; ++i) {
            hipDeviceProp_t prop;
            hipGetDeviceProperties(&prop, i);
            gpus.push_back({i, prop.name, prop.totalGlobalMem, false});
        }
#endif

        return gpus;
    }

    static void PrintGPUInventory() {
        auto gpus = DiscoverGPUs();
        std::cout << "--- GPU Inventory ---" << std::endl;
        for (const auto& gpu : gpus) {
            std::cout << "ID: " << gpu.id 
                      << " | Vendor: " << (gpu.is_nvidia ? "NVIDIA" : "AMD")
                      << " | Name: " << gpu.name 
                      << " | VRAM: " << (gpu.total_memory / (1024 * 1024)) << " MB" 
                      << std::endl;
        }
    }
};

} // namespace crystal

#endif // GPU_MANAGER_H
