// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

#include "hcl_encode_plugin.h"
#include <cstring>
#include <iostream>
#include <vector>
#include <cassert>

namespace tensorrt_llm::plugins {

extern "C" void invokeHCLEncode(const void* input, void* output, int n, int dim, int typeId, cudaStream_t stream);

nvinfer1::PluginFieldCollection HCLEncodePluginCreator::mFC{};
std::vector<nvinfer1::PluginField> HCLEncodePluginCreator::mPluginAttributes;

HCLEncodePlugin::HCLEncodePlugin(int dim) : mDim(dim) {}

HCLEncodePlugin::HCLEncodePlugin(const void* data, size_t length) {
    const char* d = static_cast<const char*>(data);
    const char* a = d;
    mDim = *reinterpret_cast<const int*>(d);
    d += sizeof(int);
    assert(d == a + length);
}

nvinfer1::DimsExprs HCLEncodePlugin::getOutputDimensions(int outputIndex,
    const nvinfer1::DimsExprs* inputs, int nbInputs,
    nvinfer1::IExprBuilder& exprBuilder) noexcept {
    return inputs[0];
}

bool HCLEncodePlugin::supportsFormatCombination(int pos, const nvinfer1::PluginTensorDesc* inOut,
    int nbInputs, int nbOutputs) noexcept {
    bool typeOk = (inOut[pos].type == nvinfer1::DataType::kFLOAT) || 
                  (inOut[pos].type == nvinfer1::DataType::kHALF);
    if (pos == 1) {
        return typeOk && (inOut[0].format == inOut[1].format) && (inOut[0].type == inOut[1].type);
    }
    return typeOk && (inOut[pos].format == nvinfer1::TensorFormat::kLINEAR);
}

void HCLEncodePlugin::configurePlugin(const nvinfer1::DynamicPluginTensorDesc* in, int nbInputs,
    const nvinfer1::DynamicPluginTensorDesc* out, int nbOutputs) noexcept {
}

size_t HCLEncodePlugin::getWorkspaceSize(const nvinfer1::PluginTensorDesc* inputs, int nbInputs,
    const nvinfer1::PluginTensorDesc* outputs, int nbOutputs) const noexcept {
    return 0;
}

int HCLEncodePlugin::enqueue(const nvinfer1::PluginTensorDesc* inputDesc,
    const nvinfer1::PluginTensorDesc* outputDesc,
    const void* const* inputs, void* const* outputs,
    void* workspace, cudaStream_t stream) noexcept {
    
    int n = 1;
    for (int i = 0; i < inputDesc[0].dims.nbDims; ++i) {
        n *= inputDesc[0].dims.d[i];
    }
    int typeId = (inputDesc[0].type == nvinfer1::DataType::kHALF) ? 1 : 0;
    
    invokeHCLEncode(inputs[0], outputs[0], n, mDim, typeId, stream);
    
    return 0;
}

nvinfer1::DataType HCLEncodePlugin::getOutputDataType(int index, const nvinfer1::DataType* inputTypes,
    int nbInputs) const noexcept {
    return inputTypes[0];
}

const char* HCLEncodePlugin::getPluginType() const noexcept { return HCL_ENCODE_PLUGIN_NAME; }
const char* HCLEncodePlugin::getPluginVersion() const noexcept { return HCL_ENCODE_PLUGIN_VERSION; }
int HCLEncodePlugin::getNbOutputs() const noexcept { return 1; }
int HCLEncodePlugin::initialize() noexcept { return 0; }
void HCLEncodePlugin::terminate() noexcept {}

size_t HCLEncodePlugin::getSerializationSize() const noexcept {
    return sizeof(mDim);
}

void HCLEncodePlugin::serialize(void* buffer) const noexcept {
    *reinterpret_cast<int*>(buffer) = mDim;
}

void HCLEncodePlugin::destroy() noexcept { delete this; }

nvinfer1::IPluginV2DynamicExt* HCLEncodePlugin::clone() const noexcept {
    auto* plugin = new HCLEncodePlugin(mDim);
    plugin->setPluginNamespace(mNamespace.c_str());
    return plugin;
}

void HCLEncodePlugin::setPluginNamespace(const char* pluginNamespace) noexcept {
    mNamespace = pluginNamespace;
}

const char* HCLEncodePlugin::getPluginNamespace() const noexcept {
    return mNamespace.c_str();
}

// Creator
HCLEncodePluginCreator::HCLEncodePluginCreator() {
    mPluginAttributes.clear();
    mPluginAttributes.emplace_back(nvinfer1::PluginField("dim", nullptr, nvinfer1::PluginFieldType::kINT32, 1));
    mFC.nbFields = mPluginAttributes.size();
    mFC.fields = mPluginAttributes.data();
}

const char* HCLEncodePluginCreator::getPluginName() const noexcept { return HCL_ENCODE_PLUGIN_NAME; }
const char* HCLEncodePluginCreator::getPluginVersion() const noexcept { return HCL_ENCODE_PLUGIN_VERSION; }

const nvinfer1::PluginFieldCollection* HCLEncodePluginCreator::getFieldNames() noexcept { return &mFC; }

nvinfer1::IPluginV2* HCLEncodePluginCreator::createPlugin(const char* name, const nvinfer1::PluginFieldCollection* fc) noexcept {
    int dim = 7;
    const nvinfer1::PluginField* fields = fc->fields;
    for (int i = 0; i < fc->nbFields; ++i) {
        if (!strcmp(fields[i].name, "dim")) {
            dim = *(static_cast<const int*>(fields[i].data));
        }
    }
    return new HCLEncodePlugin(dim);
}

nvinfer1::IPluginV2* HCLEncodePluginCreator::deserializePlugin(const char* name, const void* serialData, size_t serialLength) noexcept {
    return new HCLEncodePlugin(serialData, serialLength);
}

void HCLEncodePluginCreator::setPluginNamespace(const char* pluginNamespace) noexcept { mNamespace = pluginNamespace; }
const char* HCLEncodePluginCreator::getPluginNamespace() const noexcept { return mNamespace.c_str(); }

REGISTER_TENSORRT_PLUGIN(HCLEncodePluginCreator);

} // namespace tensorrt_llm::plugins
