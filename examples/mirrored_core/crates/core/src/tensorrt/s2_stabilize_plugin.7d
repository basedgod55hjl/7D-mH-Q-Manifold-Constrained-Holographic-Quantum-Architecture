// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

#include "s2_stabilize_plugin.h"
#include <cstring>
#include <iostream>
#include <vector>
#include <cassert>

namespace tensorrt_llm::plugins {

extern "C" void invokeS2Stabilize(const void* input, void* output, int n, int typeId, HyperbolicReal lipschitz_bound, cudaStream_t stream);

nvinfer1::PluginFieldCollection S2StabilizePluginCreator::mFC{};
std::vector<nvinfer1::PluginField> S2StabilizePluginCreator::mPluginAttributes;

S2StabilizePlugin::S2StabilizePlugin(HyperbolicReal lipschitz_bound) : mLipschitzBound(lipschitz_bound) {}

S2StabilizePlugin::S2StabilizePlugin(const void* data, size_t length) {
    const char* d = static_cast<const char*>(data);
    const char* a = d;
    mLipschitzBound = *reinterpret_cast<const HyperbolicReal*>(d);
    d += sizeof(HyperbolicReal);
    assert(d == a + length);
}

nvinfer1::DimsExprs S2StabilizePlugin::getOutputDimensions(int outputIndex,
    const nvinfer1::DimsExprs* inputs, int nbInputs,
    nvinfer1::IExprBuilder& exprBuilder) noexcept {
    return inputs[0];
}

bool S2StabilizePlugin::supportsFormatCombination(int pos, const nvinfer1::PluginTensorDesc* inOut,
    int nbInputs, int nbOutputs) noexcept {
    bool typeOk = (inOut[pos].type == nvinfer1::DataType::kFLOAT) || 
                  (inOut[pos].type == nvinfer1::DataType::kHALF);
    if (pos == 1) {
        return typeOk && (inOut[0].format == inOut[1].format) && (inOut[0].type == inOut[1].type);
    }
    return typeOk && (inOut[pos].format == nvinfer1::TensorFormat::kLINEAR);
}

void S2StabilizePlugin::configurePlugin(const nvinfer1::DynamicPluginTensorDesc* in, int nbInputs,
    const nvinfer1::DynamicPluginTensorDesc* out, int nbOutputs) noexcept {
}

size_t S2StabilizePlugin::getWorkspaceSize(const nvinfer1::PluginTensorDesc* inputs, int nbInputs,
    const nvinfer1::PluginTensorDesc* outputs, int nbOutputs) const noexcept {
    return 0;
}

int S2StabilizePlugin::enqueue(const nvinfer1::PluginTensorDesc* inputDesc,
    const nvinfer1::PluginTensorDesc* outputDesc,
    const void* const* inputs, void* const* outputs,
    void* workspace, cudaStream_t stream) noexcept {
    
    int n = 1;
    for (int i = 0; i < inputDesc[0].dims.nbDims; ++i) {
        n *= inputDesc[0].dims.d[i];
    }
    int typeId = (inputDesc[0].type == nvinfer1::DataType::kHALF) ? 1 : 0;
    
    invokeS2Stabilize(inputs[0], outputs[0], n, typeId, mLipschitzBound, stream);
    
    return 0;
}

nvinfer1::DataType S2StabilizePlugin::getOutputDataType(int index, const nvinfer1::DataType* inputTypes,
    int nbInputs) const noexcept {
    return inputTypes[0];
}

const char* S2StabilizePlugin::getPluginType() const noexcept { return S2_STABILIZE_PLUGIN_NAME; }
const char* S2StabilizePlugin::getPluginVersion() const noexcept { return S2_STABILIZE_PLUGIN_VERSION; }
int S2StabilizePlugin::getNbOutputs() const noexcept { return 1; }
int S2StabilizePlugin::initialize() noexcept { return 0; }
void S2StabilizePlugin::terminate() noexcept {}

size_t S2StabilizePlugin::getSerializationSize() const noexcept { return sizeof(HyperbolicReal); }

void S2StabilizePlugin::serialize(void* buffer) const noexcept {
    *reinterpret_cast<HyperbolicReal*>(buffer) = mLipschitzBound;
}

void S2StabilizePlugin::destroy() noexcept { delete this; }

nvinfer1::IPluginV2DynamicExt* S2StabilizePlugin::clone() const noexcept {
    auto* plugin = new S2StabilizePlugin(mLipschitzBound);
    plugin->setPluginNamespace(mNamespace.c_str());
    return plugin;
}

void S2StabilizePlugin::setPluginNamespace(const char* pluginNamespace) noexcept { mNamespace = pluginNamespace; }
const char* S2StabilizePlugin::getPluginNamespace() const noexcept { return mNamespace.c_str(); }

// Creator
S2StabilizePluginCreator::S2StabilizePluginCreator() {
    mPluginAttributes.clear();
    mPluginAttributes.emplace_back(nvinfer1::PluginField("lipschitz_bound", nullptr, nvinfer1::PluginFieldType::kFLOAT32, 1));
    mFC.nbFields = mPluginAttributes.size();
    mFC.fields = mPluginAttributes.data();
}

const char* S2StabilizePluginCreator::getPluginName() const noexcept { return S2_STABILIZE_PLUGIN_NAME; }
const char* S2StabilizePluginCreator::getPluginVersion() const noexcept { return S2_STABILIZE_PLUGIN_VERSION; }

const nvinfer1::PluginFieldCollection* S2StabilizePluginCreator::getFieldNames() noexcept { return &mFC; }

nvinfer1::IPluginV2* S2StabilizePluginCreator::createPlugin(const char* name, const nvinfer1::PluginFieldCollection* fc) noexcept {
    HyperbolicReal bound = PHIf;
    const nvinfer1::PluginField* fields = fc->fields;
    for (int i = 0; i < fc->nbFields; ++i) {
        if (!strcmp(fields[i].name, "lipschitz_bound")) {
            bound = *(static_cast<const HyperbolicReal*>(fields[i].data));
        }
    }
    return new S2StabilizePlugin(bound);
}

nvinfer1::IPluginV2* S2StabilizePluginCreator::deserializePlugin(const char* name, const void* serialData, size_t serialLength) noexcept {
    return new S2StabilizePlugin(serialData, serialLength);
}

void S2StabilizePluginCreator::setPluginNamespace(const char* pluginNamespace) noexcept { mNamespace = pluginNamespace; }
const char* S2StabilizePluginCreator::getPluginNamespace() const noexcept { return mNamespace.c_str(); }

REGISTER_TENSORRT_PLUGIN(S2StabilizePluginCreator);

} // namespace tensorrt_llm::plugins
