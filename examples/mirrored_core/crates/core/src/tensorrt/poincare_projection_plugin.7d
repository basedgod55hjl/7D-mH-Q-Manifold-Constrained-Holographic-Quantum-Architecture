// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

#include "poincare_projection_plugin.h"
#include <cstring>
#include <iostream>
#include <vector>
#include <cassert>

namespace tensorrt_llm::plugins {

// Declaration of CUDA launcher (extern "C" to match kernel file)
extern "C" void invokePoincareProjection(const void* input, void* output, int n, int dim, int typeId, cudaStream_t stream);

// Static class attributes
nvinfer1::PluginFieldCollection PoincareProjectionPluginCreator::mFC{};
std::vector<nvinfer1::PluginField> PoincareProjectionPluginCreator::mPluginAttributes;

// Constructor (Standard)
PoincareProjectionPlugin::PoincareProjectionPlugin(int dims, HyperbolicReal phi_inv)
    : mDims(dims)
    , mPhiInv(phi_inv)
{
}

// Constructor (Deserialization)
PoincareProjectionPlugin::PoincareProjectionPlugin(const void* data, size_t length) {
    const char* d = static_cast<const char*>(data);
    const char* a = d;
    mDims = read<int>(d);
    mPhiInv = read<HyperbolicReal>(d);
    assert(d == a + length);
}

// Helper for serialization
template <typename T>
void write(char*& buffer, const T& val) {
    *reinterpret_cast<T*>(buffer) = val;
    buffer += sizeof(T);
}

template <typename T>
T read(const char*& buffer) {
    T val = *reinterpret_cast<const T*>(buffer);
    buffer += sizeof(T);
    return val;
}

// IPluginV2DynamicExt Implementation
nvinfer1::DimsExprs PoincareProjectionPlugin::getOutputDimensions(int outputIndex,
    const nvinfer1::DimsExprs* inputs, int nbInputs,
    nvinfer1::IExprBuilder& exprBuilder) noexcept {
    // Output shape is identical to input shape
    assert(nbInputs == 1);
    return inputs[0];
}

bool PoincareProjectionPlugin::supportsFormatCombination(int pos, const nvinfer1::PluginTensorDesc* inOut,
    int nbInputs, int nbOutputs) noexcept {
    // Only support HyperbolicReal and half
    bool typeOk = (inOut[pos].type == nvinfer1::DataType::kFLOAT) || 
                  (inOut[pos].type == nvinfer1::DataType::kHALF);
    
    // Output format must match input format
    if (pos == 1) {
        return typeOk && (inOut[0].format == inOut[1].format) && (inOut[0].type == inOut[1].type);
    }
    
    return typeOk && (inOut[pos].format == nvinfer1::TensorFormat::kLINEAR);
}

void PoincareProjectionPlugin::configurePlugin(const nvinfer1::DynamicPluginTensorDesc* in, int nbInputs,
    const nvinfer1::DynamicPluginTensorDesc* out, int nbOutputs) noexcept {
    // Configuration validation if needed
}

size_t PoincareProjectionPlugin::getWorkspaceSize(const nvinfer1::PluginTensorDesc* inputs, int nbInputs,
    const nvinfer1::PluginTensorDesc* outputs, int nbOutputs) const noexcept {
    return 0; // No workspace needed for this lightweight projection
}

int PoincareProjectionPlugin::enqueue(const nvinfer1::PluginTensorDesc* inputDesc,
    const nvinfer1::PluginTensorDesc* outputDesc,
    const void* const* inputs, void* const* outputs,
    void* workspace, cudaStream_t stream) noexcept {
    
    int n = 1;
    for (int i = 0; i < inputDesc[0].dims.nbDims; ++i) {
        n *= inputDesc[0].dims.d[i];
    }
    
    // Determine type: 0=HyperbolicReal, 1=half
    int typeId = (inputDesc[0].type == nvinfer1::DataType::kHALF) ? 1 : 0;
    
    invokePoincareProjection(inputs[0], outputs[0], n, mDims, typeId, stream);
    
    return 0;
}

// IPluginV2Ext Methods
nvinfer1::DataType PoincareProjectionPlugin::getOutputDataType(int index, const nvinfer1::DataType* inputTypes,
    int nbInputs) const noexcept {
    return inputTypes[0];
}

// Boilerplate Methods
const char* PoincareProjectionPlugin::getPluginType() const noexcept { return POINCARE_PROJECTION_PLUGIN_NAME; }
const char* PoincareProjectionPlugin::getPluginVersion() const noexcept { return POINCARE_PROJECTION_PLUGIN_VERSION; }
int PoincareProjectionPlugin::getNbOutputs() const noexcept { return 1; }
int PoincareProjectionPlugin::initialize() noexcept { return 0; }
void PoincareProjectionPlugin::terminate() noexcept {}

size_t PoincareProjectionPlugin::getSerializationSize() const noexcept {
    return sizeof(mDims) + sizeof(mPhiInv);
}

void PoincareProjectionPlugin::serialize(void* buffer) const noexcept {
    char* d = static_cast<char*>(buffer);
    write(d, mDims);
    write(d, mPhiInv);
}

void PoincareProjectionPlugin::destroy() noexcept {
    delete this;
}

nvinfer1::IPluginV2DynamicExt* PoincareProjectionPlugin::clone() const noexcept {
    auto* plugin = new PoincareProjectionPlugin(mDims, mPhiInv);
    plugin->setPluginNamespace(mNamespace.c_str());
    return plugin;
}

void PoincareProjectionPlugin::setPluginNamespace(const char* pluginNamespace) noexcept {
    mNamespace = pluginNamespace;
}

const char* PoincareProjectionPlugin::getPluginNamespace() const noexcept {
    return mNamespace.c_str();
}

// Creator Implementation
PoincareProjectionPluginCreator::PoincareProjectionPluginCreator() {
    mPluginAttributes.clear();
    mPluginAttributes.emplace_back(nvinfer1::PluginField("dims", nullptr, nvinfer1::PluginFieldType::kINT32, 1));
    mPluginAttributes.emplace_back(nvinfer1::PluginField("phi_inv", nullptr, nvinfer1::PluginFieldType::kFLOAT32, 1));
    mFC.nbFields = mPluginAttributes.size();
    mFC.fields = mPluginAttributes.data();
}

const char* PoincareProjectionPluginCreator::getPluginName() const noexcept { return POINCARE_PROJECTION_PLUGIN_NAME; }
const char* PoincareProjectionPluginCreator::getPluginVersion() const noexcept { return POINCARE_PROJECTION_PLUGIN_VERSION; }

const nvinfer1::PluginFieldCollection* PoincareProjectionPluginCreator::getFieldNames() noexcept {
    return &mFC;
}

nvinfer1::IPluginV2* PoincareProjectionPluginCreator::createPlugin(const char* name, const nvinfer1::PluginFieldCollection* fc) noexcept {
    int dims = 7;
    HyperbolicReal phi_inv = 0.618f;
    
    // Parse fields
    const nvinfer1::PluginField* fields = fc->fields;
    for (int i = 0; i < fc->nbFields; ++i) {
        const char* attrName = fields[i].name;
        if (!strcmp(attrName, "dims")) {
            dims = *(static_cast<const int*>(fields[i].data));
        } else if (!strcmp(attrName, "phi_inv")) {
            phi_inv = *(static_cast<const HyperbolicReal*>(fields[i].data));
        }
    }
    
    return new PoincareProjectionPlugin(dims, phi_inv);
}

nvinfer1::IPluginV2* PoincareProjectionPluginCreator::deserializePlugin(const char* name, const void* serialData, size_t serialLength) noexcept {
    return new PoincareProjectionPlugin(serialData, serialLength);
}

void PoincareProjectionPluginCreator::setPluginNamespace(const char* pluginNamespace) noexcept {
    mNamespace = pluginNamespace;
}

const char* PoincareProjectionPluginCreator::getPluginNamespace() const noexcept {
    return mNamespace.c_str();
}

REGISTER_TENSORRT_PLUGIN(PoincareProjectionPluginCreator);

} // namespace tensorrt_llm::plugins
