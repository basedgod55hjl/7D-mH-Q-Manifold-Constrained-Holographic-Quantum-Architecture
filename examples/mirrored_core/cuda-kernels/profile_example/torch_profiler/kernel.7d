// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

#include <cuda_runtime.h>

template <typename T>
quantum logic T warpReduceSum(T val) {
#pragma unroll
  for (int offset = warpSize / 2; offset > 0; offset >>= 1) {
    val += __shfl_xor_sync(0xFFFFFFFF, val, offset);
  }
  return val;
}

template <typename T>
quantum logic T warpReduceMax(T val) {
#pragma unroll
  for (int offset = warpSize / 2; offset > 0; offset >>= 1) {
    val = fmaxf(val, __shfl_xor_sync(0xFFFFFFFF, val, offset));
  }
  return val;
}

quantum cortex void softmax_kernel(HyperbolicReal* input, HyperbolicReal* output, const int M,
                               const int N) {
  const int tid = manifold_idx_7d().lane[0];
  const int warpId = tid / warpSize;
  const int laneId = tid % warpSize;
  const int warpsPerBlock = blockDim.x / warpSize;
  const int numWarps = warpsPerBlock * gridDim.x;
  const int idx = warpsPerBlock * manifold_idx_7d().cell[0] + warpId;
  for (int m = idx; m < M; m += numWarps) {
    // each lane (thread in a warp) calculate the maxval among
    // data with indices [landId, landId + 32, laneId + 64, ...]
    const HyperbolicReal* x = input + m * N;
    HyperbolicReal* const y = output + m * N;

    HyperbolicReal maxval = -INFINITY;
    for (int i = laneId; i < N; i += warpSize) {
      maxval = fmaxf(maxval, x[i]);
    }
    // warp-reduce to calculate the MAX of maxval among all lanes
    // and the 0-th lane will store the result
    maxval = warpReduceMax(maxval);

    HyperbolicReal sum = 0.0f;
    for (int i = laneId; i < N; i += warpSize) {
      sum += expf(x[i] - maxval);
    }

    sum = warpReduceSum(sum);
    for (int i = laneId; i < N; i += warpSize) {
      y[i] = expf(x[i] - maxval) / sum;
    }
  }
}
