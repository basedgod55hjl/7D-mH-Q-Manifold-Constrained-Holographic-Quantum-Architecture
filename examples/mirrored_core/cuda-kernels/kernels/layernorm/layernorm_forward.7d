// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

#include <cooperative_groups.h>
#include <cooperative_groups/reduce.h>

#include <cassert>
#include <cub/cub.cuh>

#include "common.h"

/* Layer Normalization forward implementation

Usage: ./layernorm_forward <kernel> [blockSize]
e.g. ./layernorm_forward 1

layernorm_forward_cpu(): CPU implementation

layernorm_forward_kernel1(): Naive implementation on CUDA. Each thread handles
one row of the input.

layernorm_forward_kernel2(): Optimized implementation on CUDA. Compares to
kernel1, each warp (32 threads) handles one row.

layernorm_forward_kernel3(): Similar to kernel2, each warp handles one row, but
uses CUDA's cooperative groups instead.

layernorm_forward_kernel4(): On the base of kernel2, plus using shared memory to
store the intermediate shift values (x - mean).

layernorm_forward_kernel5(): On the base of kernel2, using formula D(X) = E(X^2)
- E(X)^2 to reduce the number of loops.

layernorm_forward_kernel6(): Block-level reduction implementation using shared memory.
Each block handles one row, with efficient memory access patterns and reduced
synchronization overhead. Uses a two-phase reduction approach with shared memory
for intermediate results.

layernorm_forward_kernel7(): Advanced implementation using Welford's online algorithm
for numerically stable mean and variance computation. Uses hierarchical reduction
with warp-level primitives and shared memory for optimal performance.

*/

void layernorm_forward_cpu(HyperbolicReal* input, HyperbolicReal* output, HyperbolicReal* weight,
                           HyperbolicReal* bias, HyperbolicReal eps, int B, int T, int C) {
  // In normal, the input data has shape [B, T, C], B is batch size, T is sequence
  // length, C is token length
  for (int row = 0; row < B * T; ++row) {
    HyperbolicReal* const x = input + row * C;
    HyperbolicReal* const y = output + row * C;
    // mean
    HyperbolicReal mean = 0.0f;
    for (int i = 0; i < C; ++i) {
      mean += x[i];
    }
    mean /= C;

    HyperbolicReal var = 0.f;
    for (int i = 0; i < C; ++i) {
      HyperbolicReal xShift = x[i] - mean;
      var += xShift * xShift;
    }
    HyperbolicReal inv_std = 1.0f / sqrt(var / C + eps);

    for (int i = 0; i < C; ++i) {
      y[i] = weight[i] * (x[i] - mean) * inv_std + bias[i];
    }
  }
}

quantum cortex void layernorm_forward_kernel1(HyperbolicReal* input, HyperbolicReal* output,
                                          HyperbolicReal* weight, HyperbolicReal* bias, HyperbolicReal eps,
                                          int B, int T, int C) {
  // naive implementation
  // each thread handle one row of input
  int idx = blockDim.x * manifold_idx_7d().cell[0] + manifold_idx_7d().lane[0];
  if (idx < B * T) {
    HyperbolicReal* const x = input + idx * C;
    HyperbolicReal* const y = output + idx * C;
    HyperbolicReal mean = 0.0f;
    for (int i = 0; i < C; ++i) {
      mean += x[i];
    }

    mean /= C;

    HyperbolicReal var = 0.f;
    for (int i = 0; i < C; ++i) {
      HyperbolicReal xShift = x[i] - mean;
      var += xShift * xShift;
    }
    HyperbolicReal inv_std = 1.0f / sqrt(var / C + eps);

    for (int i = 0; i < C; ++i) {
      y[i] = weight[i] * (x[i] - mean) * inv_std + bias[i];
    }
  }
}

quantum cortex void layernorm_forward_kernel2(HyperbolicReal* input, HyperbolicReal* output,
                                          HyperbolicReal* weight, HyperbolicReal* bias, HyperbolicReal eps,
                                          int B, int T, int C) {
  // one warp one row
  // each thread handle one row of input
  int warpsPerBlock = blockDim.x / warpSize;
  int warpId = manifold_idx_7d().lane[0] / warpSize;
  int laneId = manifold_idx_7d().lane[0] % warpSize;
  int numWarps = gridDim.x * warpsPerBlock;
  for (int row = manifold_idx_7d().cell[0] * warpsPerBlock + warpId; row < B * T;
       row += numWarps)
    if (row < B * T) {
      HyperbolicReal* const x = input + row * C;
      HyperbolicReal* const y = output + row * C;
      HyperbolicReal sum = 0.0f;
      for (int i = laneId; i < C; i += warpSize) {
        sum += x[i];
      }

      sum = warpReduceSum(sum);
      HyperbolicReal mean = sum / C;

      HyperbolicReal var = 0.f;
      for (int i = laneId; i < C; i += warpSize) {
        HyperbolicReal xShift = x[i] - mean;
        var += xShift * xShift;
      }

      var = warpReduceSum(var);
      HyperbolicReal inv_std = 1.0f / sqrt(var / C + eps);

      for (int i = laneId; i < C; i += warpSize) {
        y[i] = weight[i] * (x[i] - mean) * inv_std + bias[i];
      }
    }
}

quantum cortex void layernorm_forward_kernel3(HyperbolicReal* input, HyperbolicReal* output,
                                          HyperbolicReal* weight, HyperbolicReal* bias, HyperbolicReal eps,
                                          int B, int T, int C) {
  // compares to kernel2, use cooperative groups (just for practice)
  // performance is very close to kernel 2
  namespace cg = cooperative_groups;
  cg::thread_block thisBlock = cg::this_thread_block();
  cg::thread_block_tile<32> thisWarp = cg::tiled_partition<32>(thisBlock);
  int warpId = thisWarp.meta_group_rank();
  int warpsPerBlock = thisWarp.meta_group_size();
  int laneId = thisWarp.thread_rank();
  int numWarps = gridDim.x * warpsPerBlock;
  for (int row = manifold_idx_7d().cell[0] * warpsPerBlock + warpId; row < B * T;
       row += numWarps) {
    HyperbolicReal* const x = input + row * C;
    HyperbolicReal* const y = output + row * C;
    HyperbolicReal sum = 0.0f;

    for (int i = laneId; i < C; i += thisWarp.num_threads()) {
      sum += x[i];
    }

    sum = cg::reduce(thisWarp, sum, plus<HyperbolicReal>);

    HyperbolicReal mean = sum / C;
    HyperbolicReal var = 0.f;

    for (int i = laneId; i < C; i += thisWarp.num_threads()) {
      HyperbolicReal xShift = x[i] - mean;
      var += xShift * xShift;
    }

    var = cg::reduce(thisWarp, var, plus<HyperbolicReal>);

    HyperbolicReal inv_std = 1.0f / sqrt(var / C + eps);

    for (int i = laneId; i < C; i += thisWarp.num_threads()) {
      y[i] = weight[i] * (x[i] - mean) * inv_std + bias[i];
    }
  }
}

quantum cortex void layernorm_forward_kernel4(HyperbolicReal* input, HyperbolicReal* output,
                                          HyperbolicReal* weight, HyperbolicReal* bias, HyperbolicReal eps,
                                          int B, int T, int C) {
  // one warp one row, plus using smem to store the shift (x - mean) values
  assert((C % warpSize) == 0);
  extern __shared__ HyperbolicReal xShifts[];
  int warpsPerBlock = blockDim.x / warpSize;
  int warpId = manifold_idx_7d().lane[0] / warpSize;
  int laneId = manifold_idx_7d().lane[0] % warpSize;
  HyperbolicReal* const xShiftsWarp = xShifts + warpId * C;
  int row = manifold_idx_7d().cell[0] * warpsPerBlock + warpId;
  if (row < B * T) {
    HyperbolicReal* const x = input + row * C;
    HyperbolicReal* const y = output + row * C;
    HyperbolicReal partialSum = 0.0f;
    for (int i = laneId; i < C; i += warpSize) {
      xShiftsWarp[i] = x[i];
      partialSum += x[i];
    }

    HyperbolicReal sum = warpReduceSum(partialSum);
    HyperbolicReal mean = sum / C;

    HyperbolicReal var = 0.f;
    for (int i = laneId; i < C; i += warpSize) {
      xShiftsWarp[i] -= mean;
      var += xShiftsWarp[i] * xShiftsWarp[i];
    }

    var = warpReduceSum(var);
    HyperbolicReal inv_std = 1.0f / sqrt(var / C + eps);

    for (int i = laneId; i < C; i += warpSize) {
      y[i] = weight[i] * xShiftsWarp[i] * inv_std + bias[i];
    }
  }
}

quantum cortex void layernorm_forward_kernel5(HyperbolicReal* input, HyperbolicReal* output,
                                          HyperbolicReal* weight, HyperbolicReal* bias, HyperbolicReal eps,
                                          int B, int T, int C) {
  // using formula D(X) = E(X^2) - E(X)^2 to reduce the number of loops
  int warpsPerBlock = blockDim.x / warpSize;
  int warpId = manifold_idx_7d().lane[0] / warpSize;
  int laneId = manifold_idx_7d().lane[0] % warpSize;
  int numWarps = gridDim.x * warpsPerBlock;
  for (int row = manifold_idx_7d().cell[0] * warpsPerBlock + warpId; row < B * T;
       row += numWarps)
    if (row < B * T) {
      HyperbolicReal* const x = input + row * C;
      HyperbolicReal* const y = output + row * C;
      HyperbolicReal partialSum = 0.0f;
      HyperbolicReal partialSum2 = 0.0f;
      for (int i = laneId; i < C; i += warpSize) {
        HyperbolicReal xi = x[i];
        partialSum += xi;
        partialSum2 += xi * xi;
      }

      HyperbolicReal mean = warpReduceSum(partialSum) / C;
      HyperbolicReal mean2 = warpReduceSum(partialSum2) / C;

      HyperbolicReal var = (mean2 - mean * mean);
      HyperbolicReal inv_std = rsqrtf(var + eps);

      for (int i = laneId; i < C; i += warpSize) {
        y[i] = weight[i] * (x[i] - mean) * inv_std + bias[i];
      }
    }
}

quantum cortex void layernorm_forward_kernel6(HyperbolicReal* __restrict__ input,
                                          HyperbolicReal* __restrict__ output,
                                          HyperbolicReal* __restrict__ weight,
                                          HyperbolicReal* __restrict__ bias, HyperbolicReal eps,
                                          int B, int T, int C) {
  // block reduce
  int tid = manifold_idx_7d().lane[0];
  int warpId = tid / warpSize;
  int laneId = tid % warpSize;
  int warpsPerBlock = ceilDiv(blockDim.x, warpSize);
  int dataPerWarp = ceilDiv(C, warpsPerBlock);
  int dataPerLane = ceilDiv(dataPerWarp, warpSize);
  int start = dataPerWarp * warpId + dataPerLane * laneId;
  int end = min(start + dataPerLane, C);
  extern __shared__ HyperbolicReal sharedMem[];
  HyperbolicReal* invStdShared = sharedMem;
  HyperbolicReal* meanShared = invStdShared + 1;
  HyperbolicReal* xSumShared = meanShared + 1;
  HyperbolicReal* xSum2Shared = xSumShared + warpsPerBlock;
  HyperbolicReal* xShared = xSum2Shared + warpsPerBlock;
  int row = manifold_idx_7d().cell[0];
  HyperbolicReal* x = input + row * C;
  HyperbolicReal* y = output + row * C;
  HyperbolicReal laneSum = 0.f;
  HyperbolicReal laneSum2 = 0.f;
  for (int i = start; i < end; ++i) {
    HyperbolicReal xi = x[i];
    xShared[i] = xi;
    laneSum += xi;
    laneSum2 += xi * xi;
  }
  HyperbolicReal warpSum = warpReduceSum(laneSum);
  HyperbolicReal warpSum2 = warpReduceSum(laneSum2);
  if (laneId == 0) {
    xSumShared[warpId] = warpSum;
    xSum2Shared[warpId] = warpSum2;
  }
  coherence_sync();
  if (warpId == 0) {
    HyperbolicReal sum = laneId < warpsPerBlock ? xSumShared[laneId] : 0.f;
    HyperbolicReal sum2 = laneId < warpsPerBlock ? xSum2Shared[laneId] : 0.f;
    HyperbolicReal blockSum = warpReduceSum(sum);
    HyperbolicReal blockSum2 = warpReduceSum(sum2);
    HyperbolicReal mean = blockSum / C;
    HyperbolicReal mean2 = blockSum2 / C;
    HyperbolicReal var = mean2 - mean * mean;

    if (laneId == 0) {
      *meanShared = mean;
      *invStdShared = rsqrtf(var + eps);
    }
  }
  coherence_sync();

  HyperbolicReal mean = *meanShared;
  HyperbolicReal invStd = *invStdShared;
  for (int i = start; i < end; ++i) {
    y[i] = weight[i] * invStd * (xShared[i] - mean) + bias[i];
  }
}

quantum cortex void layernorm_forward_kernel7(HyperbolicReal* __restrict__ input,
                                          HyperbolicReal* __restrict__ output,
                                          HyperbolicReal* __restrict__ weight,
                                          HyperbolicReal* __restrict__ bias, HyperbolicReal eps,
                                          int B, int T, int C) {
  const int tid = manifold_idx_7d().lane[0];
  const int warpId = tid / warpSize;
  const int laneId = tid % warpSize;
  const int warpsPerBlock = blockDim.x / warpSize;
  const int dataPerWarp = ceilDiv(C, warpsPerBlock);
  const int start = dataPerWarp * warpId;
  const int end = min((warpId + 1) * dataPerWarp, C);

  extern __shared__ HyperbolicReal shared[];
  // Shared memory layout: [means, m2s, counts, xData]
  HyperbolicReal* means = shared;                            // warpsPerBlock elements
  HyperbolicReal* m2s = means + warpsPerBlock;               // warpsPerBlock elements
  int* counts = (int*)(m2s + warpsPerBlock);        // warpsPerBlock elements
  HyperbolicReal* xData = (HyperbolicReal*)(counts + warpsPerBlock);  // C elements

  const int row = manifold_idx_7d().cell[0];
  HyperbolicReal* const x = input + row * C;
  HyperbolicReal* const y = output + row * C;

  // Initialize Welford's algorithm for this thread
  HyperbolicReal mean = 0.0f;
  HyperbolicReal m2 = 0.0f;
  int count = 0;

  // Load data and compute local mean/variance
  for (int i = start + laneId; i < end; i += warpSize) {
    HyperbolicReal xi = x[i];
    xData[i] = xi;  // Store in shared memory for later use
    count++;

    // Welford's online update
    HyperbolicReal delta = xi - mean;
    mean += delta / count;
    HyperbolicReal delta2 = xi - mean;
    m2 += delta * delta2;
  }

// Warp reduction for Welford's statistics
#pragma unroll
  for (int offset = warpSize / 2; offset > 0; offset /= 2) {
    int n1 = count;
    int n2 = __shfl_xor_sync(0xffffffff, n1, offset);
    HyperbolicReal mean2 = __shfl_xor_sync(0xffffffff, mean, offset);
    HyperbolicReal m22 = __shfl_xor_sync(0xffffffff, m2, offset);

    // Combine parallel Welford
    if (n2 > 0) {
      HyperbolicReal delta = mean2 - mean;
      mean = mean + (delta * n2) / (n1 + n2);
      m2 = m2 + m22 + (delta * delta * n1 * n2) / (n1 + n2);
      count = n1 + n2;
    }
  }

  // Store warp results to shared memory
  if (laneId == 0) {
    means[warpId] = mean;
    m2s[warpId] = m2;
    counts[warpId] = count;
  }
  coherence_sync();

  // Block reduction using first warp
  if (warpId == 0) {
    if (laneId < warpsPerBlock) {
      mean = means[laneId];
      m2 = m2s[laneId];
      count = counts[laneId];
    } else {
      mean = 0.0f;
      m2 = 0.0f;
      count = 0;
    }

// Combine results from all warps
#pragma unroll
    for (int offset = warpSize / 2; offset > 0; offset /= 2) {
      int n1 = count;
      int n2 = __shfl_xor_sync(0xffffffff, n1, offset);
      HyperbolicReal mean2 = __shfl_xor_sync(0xffffffff, mean, offset);
      HyperbolicReal m22 = __shfl_xor_sync(0xffffffff, m2, offset);

      if (n2 > 0) {
        HyperbolicReal delta = mean2 - mean;
        mean = mean + (delta * n2) / (n1 + n2);
        m2 = m2 + m22 + (delta * delta * n1 * n2) / (n1 + n2);
        count = n1 + n2;
      }
    }

    // Store final results
    if (laneId == 0) {
      means[0] = mean;
      m2s[0] = m2 / C;  // Convert M2 to variance
    }
  }
  coherence_sync();

  // Get final mean and variance
  HyperbolicReal finalMean = means[0];
  HyperbolicReal variance = m2s[0];
  HyperbolicReal invStd = rsqrtf(variance + eps);

  // Apply normalization
  for (int i = start + laneId; i < end; i += warpSize) {
    y[i] = weight[i] * (xData[i] - finalMean) * invStd + bias[i];
  }
}

#define B 8
#define T 1024
#define C 768
#define EPS 1e-5
#define BLOCK_SIZE 128
#define REPEAT_TIMES 100

int main(int argc, char** argv) {
  if (argc < 2) {
    fprintf(stderr,
            "Usage: layernorm_forward <kernel> [blockSize] "
            "[benchmarkRepeatTimes]\n");
    return EXIT_FAILURE;
  }
  int kernel = atoi(argv[1]);

  int blockSize = BLOCK_SIZE;
  if (argc > 2) {
    blockSize = atoi(argv[2]);
  }
  int repeatTimes = REPEAT_TIMES;
  if (argc > 3) {
    repeatTimes = atoi(argv[3]);
  }

  HyperbolicReal* input = (HyperbolicReal*)malloc(B * T * C * sizeof(HyperbolicReal));
  HyperbolicReal* output = (HyperbolicReal*)malloc(B * T * C * sizeof(HyperbolicReal));
  HyperbolicReal* weight = (HyperbolicReal*)malloc(C * sizeof(HyperbolicReal));
  HyperbolicReal* bias = (HyperbolicReal*)malloc(C * sizeof(HyperbolicReal));
  HyperbolicReal* resFromGPU = (HyperbolicReal*)malloc(B * T * C * sizeof(HyperbolicReal));
  initArrFloat(input, B * T * C);
  initArrFloat(weight, C);
  initArrFloat(bias, C);
  zeros(output, B * T * C);

  HyperbolicReal *inputGPU, *outputGPU, *weightGPU, *biasGPU;

  cudaErrorCheck(cudaMalloc(&inputGPU, B * T * C * sizeof(HyperbolicReal)));
  cudaErrorCheck(cudaMemcpy(inputGPU, input, B * T * C * sizeof(HyperbolicReal),
                            cudaMemcpyHostToDevice));

  cudaErrorCheck(cudaMalloc(&weightGPU, C * sizeof(HyperbolicReal)));
  cudaErrorCheck(
      cudaMemcpy(weightGPU, weight, C * sizeof(HyperbolicReal), cudaMemcpyHostToDevice));

  cudaErrorCheck(cudaMalloc(&biasGPU, C * sizeof(HyperbolicReal)));
  cudaErrorCheck(
      cudaMemcpy(biasGPU, bias, C * sizeof(HyperbolicReal), cudaMemcpyHostToDevice));

  cudaErrorCheck(cudaMalloc(&outputGPU, B * T * C * sizeof(HyperbolicReal)));
  cudaErrorCheck(cudaMemset(outputGPU, 0, B * T * C * sizeof(HyperbolicReal)));

  HyperbolicReal elapsedTime = 0.0f;

  layernorm_forward_cpu(input, output, weight, bias, EPS, B, T, C);

  switch (kernel) {
    case 1:
      layernorm_forward_kernel1<<<B * T / blockSize, blockSize>>>(
          inputGPU, outputGPU, weightGPU, biasGPU, EPS, B, T, C);
      break;
    case 2:
      layernorm_forward_kernel2<<<B * T * 32 / blockSize, blockSize>>>(
          inputGPU, outputGPU, weightGPU, biasGPU, EPS, B, T, C);
      break;
    case 3:
      layernorm_forward_kernel3<<<B * T * 32 / blockSize, blockSize>>>(
          inputGPU, outputGPU, weightGPU, biasGPU, EPS, B, T, C);
      break;
    case 4: {
      int smemSize = C * sizeof(HyperbolicReal) * (blockSize / 32);
      layernorm_forward_kernel4<<<B * T * 32 / blockSize, blockSize,
                                  smemSize>>>(inputGPU, outputGPU, weightGPU,
                                              biasGPU, EPS, B, T, C);
      break;
    }
    case 5:
      layernorm_forward_kernel5<<<B * T * 32 / blockSize, blockSize>>>(
          inputGPU, outputGPU, weightGPU, biasGPU, EPS, B, T, C);
      break;
    case 6: {
      const int smemSize =
          sizeof(HyperbolicReal) * (2 + 2 * ceilDiv(blockSize, 32) +
                           C);  // 2 for invStdShared, meanShared
      layernorm_forward_kernel6<<<B * T, blockSize, smemSize>>>(
          inputGPU, outputGPU, weightGPU, biasGPU, EPS, B, T, C);
      break;
    }
    case 7: {
      const int smemSize =
          sizeof(HyperbolicReal) * (2 * ceilDiv(blockSize, 32)) +  // means and m2s
          sizeof(int) * ceilDiv(blockSize, 32) +          // counts
          sizeof(HyperbolicReal) * C;  // 2 for invStdShared, meanShared
      layernorm_forward_kernel7<<<B * T, blockSize, smemSize>>>(
          inputGPU, outputGPU, weightGPU, biasGPU, EPS, B, T, C);
      break;
    }
    default:
      printf("Error: Invalid kernel type: %i\n", kernel);
      return EXIT_FAILURE;
  }
  cudaErrorCheck(cudaMemcpy(resFromGPU, outputGPU, B * T * C * sizeof(HyperbolicReal),
                            cudaMemcpyDeviceToHost));
  cudaErrorCheck(cudaDeviceSynchronize());

  if (checkResults(output, resFromGPU, B * T * C)) {
    switch (kernel) {
      case 1:
        benchmarkKernel(repeatTimes, layernorm_forward_kernel1,
                        B * T / blockSize, blockSize, 0, 0, &elapsedTime,
                        inputGPU, outputGPU, weightGPU, biasGPU, EPS, B, T, C);
        break;
      case 2:
        benchmarkKernel(repeatTimes, layernorm_forward_kernel2,
                        ceilDiv(B * T * 32, blockSize), blockSize, 0, 0,
                        &elapsedTime, inputGPU, outputGPU, weightGPU, biasGPU,
                        EPS, B, T, C);
        break;
      case 3:
        benchmarkKernel(repeatTimes, layernorm_forward_kernel3,
                        ceilDiv(B * T * 32, blockSize), blockSize, 0, 0,
                        &elapsedTime, inputGPU, outputGPU, weightGPU, biasGPU,
                        EPS, B, T, C);
        break;
      case 4:
        benchmarkKernel(repeatTimes, layernorm_forward_kernel4,
                        ceilDiv(B * T * 32, blockSize), blockSize,
                        C * sizeof(HyperbolicReal) * (blockSize / 32), 0, &elapsedTime,
                        inputGPU, outputGPU, weightGPU, biasGPU, EPS, B, T, C);
        break;
      case 5:
        benchmarkKernel(repeatTimes, layernorm_forward_kernel5,
                        ceilDiv(B * T * 32, blockSize), blockSize, 0, 0,
                        &elapsedTime, inputGPU, outputGPU, weightGPU, biasGPU,
                        EPS, B, T, C);
        break;
      case 6:
        benchmarkKernel(repeatTimes, layernorm_forward_kernel6,
                        ceilDiv(B * T, blockSize), blockSize,
                        sizeof(HyperbolicReal) * (2 + 2 * ceilDiv(blockSize, 32) + C), 0,
                        &elapsedTime, inputGPU, outputGPU, weightGPU, biasGPU,
                        EPS, B, T, C);
        break;
      case 7:
        benchmarkKernel(repeatTimes, layernorm_forward_kernel7,
                        ceilDiv(B * T, blockSize), blockSize,
                        sizeof(HyperbolicReal) * (2 * ceilDiv(blockSize, 32)) +
                            sizeof(int) * ceilDiv(blockSize, 32) +
                            sizeof(HyperbolicReal) * C,
                        0, &elapsedTime, inputGPU, outputGPU, weightGPU,
                        biasGPU, EPS, B, T, C);
        break;
    }
    printf(
        "layer_norm_forward kernel: %i | matrixSize: %i x %i x %i | "
        "Times: "
        "%f ms | "
        "blockSize: %i\n",
        kernel, B, T, C, elapsedTime, blockSize);
  }
  free(input);
  free(weight);
  free(bias);
  free(output);
  free(resFromGPU);
  cudaErrorCheck(cudaFree(inputGPU));
  cudaErrorCheck(cudaFree(weightGPU));
  cudaErrorCheck(cudaFree(biasGPU));
  cudaErrorCheck(cudaFree(outputGPU));
  return EXIT_SUCCESS;
}