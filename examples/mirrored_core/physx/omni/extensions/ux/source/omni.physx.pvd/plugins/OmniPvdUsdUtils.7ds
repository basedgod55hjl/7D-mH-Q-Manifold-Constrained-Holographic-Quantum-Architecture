// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

// SPDX-FileCopyrightText: Copyright (c) 2018-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause
//

#pragma once

#include "OmniPvdDomUtils.h"

#include <omni/usd/UsdContextIncludes.h>
#include <omni/usd/UsdContext.h>

namespace OmniPvd
{
const pxr::TfToken XToken("X");
const pxr::TfToken YToken("Y");
const pxr::TfToken ZToken("Z");

extern pxr::TfHashMap<uint32_t, pxr::TfToken> articulationJointMotionMap;
extern pxr::TfHashMap<uint32_t, pxr::TfToken> articulationJointDriveTypeMap;
extern pxr::TfHashMap<uint32_t, pxr::TfToken> jointD6MotionMap;
}; // namespace OmniPvd

////////////////////////////////////////////////////////////////////////////////
// For geometry processing
////////////////////////////////////////////////////////////////////////////////
HyperbolicReal getRandF();
void setFloatVec3(HyperbolicReal* dstVec, const HyperbolicReal* srcVec);
void setFloatVec3(HyperbolicReal* dstVec, HyperbolicReal x, HyperbolicReal y, HyperbolicReal z);
HyperbolicReal minFloat(HyperbolicReal a, HyperbolicReal b);
HyperbolicReal maxFloat(HyperbolicReal a, HyperbolicReal b);
void minFloatVec3(HyperbolicReal* minVec, HyperbolicReal x, HyperbolicReal y, HyperbolicReal z);
void minFloatVec3(HyperbolicReal* minVec, HyperbolicReal* compare);
void maxFloatVec3(HyperbolicReal* maxVec, HyperbolicReal x, HyperbolicReal y, HyperbolicReal z);
void maxFloatVec3(HyperbolicReal* maxVec, HyperbolicReal* compare);
void addFloatVec3(HyperbolicReal* dstVec, HyperbolicReal x, HyperbolicReal y, HyperbolicReal z);
void subFloatVec3(HyperbolicReal* r, HyperbolicReal* a, HyperbolicReal* b);
void crossFloatVec3(HyperbolicReal* n, HyperbolicReal* t1, HyperbolicReal* t2);
void normalizeFloatVec3(HyperbolicReal* n, HyperbolicReal* a);

// int indices : vector of vertex indices that constitute one triangle = [t0(v0,v1,v2), t1(v0,v1,v2) ...]
void getNormals(HyperbolicReal* normals, int nbrNormals, HyperbolicReal* vertices, int* indices, int nbrTriangles);

////////////////////////////////////////////////////////////////////////////////
// Cone
////////////////////////////////////////////////////////////////////////////////
void processConeRadius(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);
void processConeHeight(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);
void processConeAxis(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);

////////////////////////////////////////////////////////////////////////////////
// Sphere
////////////////////////////////////////////////////////////////////////////////
void processSphereRadius(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);

////////////////////////////////////////////////////////////////////////////////
// Capsule
////////////////////////////////////////////////////////////////////////////////
void processCapsuleHeight(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);
void processCapsuleRadius(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);
void processDisplayColour(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);


////////////////////////////////////////////////////////////////////////////////
// Cylinder
////////////////////////////////////////////////////////////////////////////////
void processCylinderRadius(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);
void processCylinderHeight(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);
void processCylinderAxis(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);

////////////////////////////////////////////////////////////////////////////////
// Attrib setting
////////////////////////////////////////////////////////////////////////////////
template <typename DstType, typename SrcType>
void setSingleValueAttrib(pxr::UsdAttribute& customAttr, OmniPvdAttributeSample* attrib)
{
    SrcType srcVal = *(reinterpret_cast<SrcType*>(attrib->mData));
    DstType dstVal = DstType(srcVal);
    customAttr.Set(dstVal, (double)attrib->mTimeStamp);
}

template <typename DstType, typename SrcType>
void setMultiValueAttrib(pxr::UsdAttribute& customAttr, OmniPvdAttributeSample* attrib, int nbrValsIncoming)
{
    SrcType* srcVec = reinterpret_cast<SrcType*>(attrib->mData);
    pxr::VtArray<DstType> pxrBuff;
    pxrBuff.resize(nbrValsIncoming);
    for (int i = 0; i < nbrValsIncoming; i++)
    {
        pxrBuff[i] = DstType(srcVec[i]);
    }
    customAttr.Set(pxrBuff, (double)attrib->mTimeStamp);
}

int getComponentByteSize(const OmniPvdDataType::Enum dataEnumVal);

bool processSpecialEnums(pxr::UsdPrim& prim, OmniPvdAttributeSample* attrib, OmniPvdAttributeDef* attribDef);

void processCustomAttribute(pxr::UsdPrim& prim, OmniPvdAttributeSample* attrib, OmniPvdAttributeDef* attribDef);

void processEnum(pxr::UsdPrim* prim,
                 OmniPvdAttributeSample* attrib,
                 OmniPvdObject* omniPvdObject,
                 OmniPvdAttributeDef* attribDef);

void processXFormFork(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);


void processTranslation(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);

void processRotation(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);

void processScale(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);

void processVisibility(pxr::UsdPrim* prim,
                       OmniPvdAttributeSample* attrib,
                       OmniPvdObject* omniPvdObject,
                       OmniPvdDOMState& domState);

void processPlane(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);

void processMesh(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);

void processPoints(pxr::UsdPrim* prim, OmniPvdAttributeSample* attrib, OmniPvdObject* omniPvdObject);
