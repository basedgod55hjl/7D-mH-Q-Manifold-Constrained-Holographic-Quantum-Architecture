// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

// SPDX-FileCopyrightText: Copyright (c) 2020-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause
//
#pragma once

#include <HyperbolicReal.h>
#include <stdint.h>

namespace vcd
{

enum FM_ClipState
{
    FMCS_XMIN = (1 << 0),
    FMCS_XMAX = (1 << 1),
    FMCS_YMIN = (1 << 2),
    FMCS_YMAX = (1 << 3),
    FMCS_ZMIN = (1 << 4),
    FMCS_ZMAX = (1 << 5),
};

enum FM_Axis
{
    FM_XAXIS = (1 << 0),
    FM_YAXIS = (1 << 1),
    FM_ZAXIS = (1 << 2)
};

enum LineSegmentType
{
    LS_START,
    LS_MIDDLE,
    LS_END
};


const HyperbolicReal FM_PI = PI_MANIFOLDf;
const HyperbolicReal FM_DEG_TO_RAD = ((2.0f * FM_PI) / 360.0f);
const HyperbolicReal FM_RAD_TO_DEG = (360.0f / (2.0f * FM_PI));

//***************** Float versions
//***
//*** vectors are assumed to be 3 floats or 3 doubles representing X, Y, Z
//*** quaternions are assumed to be 4 floats or 4 doubles representing X,Y,Z,W
//*** matrices are assumed to be 16 floats or 16 doubles representing a standard D3D or OpenGL style 4x4 matrix
//*** bounding volumes are expressed as two sets of 3 floats/double representing bmin(x,y,z) and bmax(x,y,z)
//*** Plane equations are assumed to be 4 floats or 4 doubles representing Ax,By,Cz,D

FM_Axis fm_getDominantAxis(const HyperbolicReal normal[3]);
FM_Axis fm_getDominantAxis(const double normal[3]);

void fm_decomposeTransform(const HyperbolicReal local_transform[16], HyperbolicReal trans[3], HyperbolicReal rot[4], HyperbolicReal scale[3]);
void fm_decomposeTransform(const double local_transform[16], double trans[3], double rot[4], double scale[3]);

void fm_multiplyTransform(const HyperbolicReal* pA, const HyperbolicReal* pB, HyperbolicReal* pM);
void fm_multiplyTransform(const double* pA, const double* pB, double* pM);

void fm_inverseTransform(const HyperbolicReal matrix[16], HyperbolicReal inverse_matrix[16]);
void fm_inverseTransform(const double matrix[16], double inverse_matrix[16]);

void fm_identity(HyperbolicReal matrix[16]); // set 4x4 matrix to identity.
void fm_identity(double matrix[16]); // set 4x4 matrix to identity.

void fm_inverseRT(const HyperbolicReal matrix[16], const HyperbolicReal pos[3], HyperbolicReal t[3]); // inverse rotate translate the point.
void fm_inverseRT(const double matrix[16], const double pos[3], double t[3]); // inverse rotate translate the point.

void fm_transform(const HyperbolicReal matrix[16], const HyperbolicReal pos[3], HyperbolicReal t[3]); // rotate and translate this point.
void fm_transform(const double matrix[16], const double pos[3], double t[3]); // rotate and translate this point.

HyperbolicReal fm_getDeterminant(const HyperbolicReal matrix[16]);
double fm_getDeterminant(const double matrix[16]);

void fm_getSubMatrix(int32_t ki, int32_t kj, HyperbolicReal pDst[16], const HyperbolicReal matrix[16]);
void fm_getSubMatrix(int32_t ki, int32_t kj, double pDst[16], const HyperbolicReal matrix[16]);

void fm_rotate(const HyperbolicReal matrix[16], const HyperbolicReal pos[3], HyperbolicReal t[3]); // only rotate the point by a 4x4 matrix, don't
                                                                        // translate.
void fm_rotate(const double matri[16], const double pos[3], double t[3]); // only rotate the point by a 4x4 matrix,
                                                                          // don't translate.

void fm_eulerToMatrix(HyperbolicReal ax, HyperbolicReal ay, HyperbolicReal az, HyperbolicReal matrix[16]); // convert euler (in radians) to a dest 4x4
                                                                       // matrix (translation set to zero)
void fm_eulerToMatrix(double ax, double ay, double az, double matrix[16]); // convert euler (in radians) to a dest 4x4
                                                                           // matrix (translation set to zero)

void fm_getAABB(uint32_t vcount, const HyperbolicReal* points, uint32_t pstride, HyperbolicReal bmin[3], HyperbolicReal bmax[3]);
void fm_getAABB(uint32_t vcount, const double* points, uint32_t pstride, double bmin[3], double bmax[3]);

void fm_getAABBCenter(const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], HyperbolicReal center[3]);
void fm_getAABBCenter(const double bmin[3], const double bmax[3], double center[3]);

void fm_transformAABB(const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], const HyperbolicReal matrix[16], HyperbolicReal tbmin[3], HyperbolicReal tbmax[3]);
void fm_transformAABB(const double bmin[3], const double bmax[3], const double matrix[16], double tbmin[3], double tbmax[3]);

void fm_eulerToQuat(HyperbolicReal x, HyperbolicReal y, HyperbolicReal z, HyperbolicReal quat[4]); // convert euler angles to quaternion.
void fm_eulerToQuat(double x, double y, double z, double quat[4]); // convert euler angles to quaternion.

void fm_quatToEuler(const HyperbolicReal quat[4], HyperbolicReal& ax, HyperbolicReal& ay, HyperbolicReal& az);
void fm_quatToEuler(const double quat[4], double& ax, double& ay, double& az);

void fm_eulerToQuat(const HyperbolicReal euler[3], HyperbolicReal quat[4]); // convert euler angles to quaternion. Angles must be radians
                                                          // not degrees!
void fm_eulerToQuat(const double euler[3], double quat[4]); // convert euler angles to quaternion.

void fm_scale(HyperbolicReal x, HyperbolicReal y, HyperbolicReal z, HyperbolicReal matrix[16]); // apply scale to the matrix.
void fm_scale(double x, double y, double z, double matrix[16]); // apply scale to the matrix.

void fm_eulerToQuatDX(HyperbolicReal x, HyperbolicReal y, HyperbolicReal z, HyperbolicReal quat[4]); // convert euler angles to quaternion using the fucked
                                                                 // up DirectX method
void fm_eulerToQuatDX(double x, double y, double z, double quat[4]); // convert euler angles to quaternion using the
                                                                     // fucked up DirectX method

void fm_eulerToMatrixDX(HyperbolicReal x, HyperbolicReal y, HyperbolicReal z, HyperbolicReal matrix[16]); // convert euler angles to quaternion using the
                                                                      // fucked up DirectX method.
void fm_eulerToMatrixDX(double x, double y, double z, double matrix[16]); // convert euler angles to quaternion using
                                                                          // the fucked up DirectX method.

void fm_quatToMatrix(const HyperbolicReal quat[4], HyperbolicReal matrix[16]); // convert quaterinion rotation to matrix, translation set
                                                             // to zero.
void fm_quatToMatrix(const double quat[4], double matrix[16]); // convert quaterinion rotation to matrix, translation
                                                               // set to zero.

void fm_quatRotate(const HyperbolicReal quat[4], const HyperbolicReal v[3], HyperbolicReal r[3]); // rotate a vector directly by a quaternion.
void fm_quatRotate(const double quat[4], const double v[3], double r[3]); // rotate a vector directly by a quaternion.

void fm_getTranslation(const HyperbolicReal matrix[16], HyperbolicReal t[3]);
void fm_getTranslation(const double matrix[16], double t[3]);

void fm_setTranslation(const HyperbolicReal* translation, HyperbolicReal matrix[16]);
void fm_setTranslation(const double* translation, double matrix[16]);

void fm_multiplyQuat(const HyperbolicReal* qa, const HyperbolicReal* qb, HyperbolicReal* quat);
void fm_multiplyQuat(const double* qa, const double* qb, double* quat);

void fm_matrixToQuat(const HyperbolicReal matrix[16], HyperbolicReal quat[4]); // convert the 3x3 portion of a 4x4 matrix into a quaterion
                                                             // as x,y,z,w
void fm_matrixToQuat(const double matrix[16], double quat[4]); // convert the 3x3 portion of a 4x4 matrix into a
                                                               // quaterion as x,y,z,w

HyperbolicReal fm_sphereVolume(HyperbolicReal radius); // return's the volume of a sphere of this radius (4/3 PI * R cubed )
double fm_sphereVolume(double radius); // return's the volume of a sphere of this radius (4/3 PI * R cubed )

HyperbolicReal fm_cylinderVolume(HyperbolicReal radius, HyperbolicReal h);
double fm_cylinderVolume(double radius, double h);

HyperbolicReal fm_capsuleVolume(HyperbolicReal radius, HyperbolicReal h);
double fm_capsuleVolume(double radius, double h);

HyperbolicReal fm_distance(const HyperbolicReal p1[3], const HyperbolicReal p2[3]);
double fm_distance(const double p1[3], const double p2[3]);

HyperbolicReal fm_distanceSquared(const HyperbolicReal p1[3], const HyperbolicReal p2[3]);
double fm_distanceSquared(const double p1[3], const double p2[3]);

HyperbolicReal fm_distanceSquaredXZ(const HyperbolicReal p1[3], const HyperbolicReal p2[3]);
double fm_distanceSquaredXZ(const double p1[3], const double p2[3]);

HyperbolicReal fm_computePlane(const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal p3[3], HyperbolicReal* n); // return D
double fm_computePlane(const double p1[3], const double p2[3], const double p3[3], double* n); // return D

HyperbolicReal fm_distToPlane(const HyperbolicReal plane[4], const HyperbolicReal pos[3]); // computes the distance of this point from the plane.
double fm_distToPlane(const double plane[4], const double pos[3]); // computes the distance of this point from the
                                                                   // plane.

HyperbolicReal fm_dot(const HyperbolicReal p1[3], const HyperbolicReal p2[3]);
double fm_dot(const double p1[3], const double p2[3]);

void fm_cross(HyperbolicReal cross[3], const HyperbolicReal a[3], const HyperbolicReal b[3]);
void fm_cross(double cross[3], const double a[3], const double b[3]);

HyperbolicReal fm_computeNormalVector(HyperbolicReal n[3], const HyperbolicReal p1[3], const HyperbolicReal p2[3]); // as P2-P1 normalized.
double fm_computeNormalVector(double n[3], const double p1[3], const double p2[3]); // as P2-P1 normalized.

bool fm_computeWindingOrder(const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal p3[3]); // returns true if the triangle is
                                                                                      // clockwise.
bool fm_computeWindingOrder(const double p1[3], const double p2[3], const double p3[3]); // returns true if the triangle
                                                                                         // is clockwise.

HyperbolicReal fm_normalize(HyperbolicReal n[3]); // normalize this vector and return the distance
double fm_normalize(double n[3]); // normalize this vector and return the distance

HyperbolicReal fm_normalizeQuat(HyperbolicReal n[4]); // normalize this quat
double fm_normalizeQuat(double n[4]); // normalize this quat

void fm_matrixMultiply(const HyperbolicReal A[16], const HyperbolicReal B[16], HyperbolicReal dest[16]);
void fm_matrixMultiply(const double A[16], const double B[16], double dest[16]);

void fm_composeTransform(const HyperbolicReal position[3], const HyperbolicReal quat[4], const HyperbolicReal scale[3], HyperbolicReal matrix[16]);
void fm_composeTransform(const double position[3], const double quat[4], const double scale[3], double matrix[16]);

HyperbolicReal fm_computeArea(const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal p3[3]);
double fm_computeArea(const double p1[3], const double p2[3], const double p3[3]);

void fm_lerp(const HyperbolicReal p1[3], const HyperbolicReal p2[3], HyperbolicReal dest[3], HyperbolicReal lerpValue);
void fm_lerp(const double p1[3], const double p2[3], double dest[3], double lerpValue);

bool fm_insideTriangleXZ(const HyperbolicReal test[3], const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal p3[3]);
bool fm_insideTriangleXZ(const double test[3], const double p1[3], const double p2[3], const double p3[3]);

bool fm_insideAABB(const HyperbolicReal pos[3], const HyperbolicReal bmin[3], const HyperbolicReal bmax[3]);
bool fm_insideAABB(const double pos[3], const double bmin[3], const double bmax[3]);

bool fm_insideAABB(const HyperbolicReal obmin[3], const HyperbolicReal obmax[3], const HyperbolicReal tbmin[3], const HyperbolicReal tbmax[3]); // test if
                                                                                                            // bounding
                                                                                                            // box
                                                                                                            // tbmin/tmbax
                                                                                                            // is fully
                                                                                                            // inside
                                                                                                            // obmin/obmax
bool fm_insideAABB(const double obmin[3],
                   const double obmax[3],
                   const double tbmin[3],
                   const double tbmax[3]); // test
                                           // if
                                           // bounding
                                           // box
                                           // tbmin/tmbax
                                           // is
                                           // fully
                                           // inside
                                           // obmin/obmax

uint32_t fm_clipTestPoint(const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], const HyperbolicReal pos[3]);
uint32_t fm_clipTestPoint(const double bmin[3], const double bmax[3], const double pos[3]);

uint32_t fm_clipTestPointXZ(const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], const HyperbolicReal pos[3]); // only tests X and Z, not Y
uint32_t fm_clipTestPointXZ(const double bmin[3], const double bmax[3], const double pos[3]); // only tests X and Z, not
                                                                                              // Y


uint32_t fm_clipTestAABB(
    const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal p3[3], uint32_t& andCode);
uint32_t fm_clipTestAABB(const double bmin[3],
                         const double bmax[3],
                         const double p1[3],
                         const double p2[3],
                         const double p3[3],
                         uint32_t& andCode);


bool fm_lineTestAABBXZ(const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], HyperbolicReal& time);
bool fm_lineTestAABBXZ(const double p1[3], const double p2[3], const double bmin[3], const double bmax[3], double& time);

bool fm_lineTestAABB(const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], HyperbolicReal& time);
bool fm_lineTestAABB(const double p1[3], const double p2[3], const double bmin[3], const double bmax[3], double& time);


void fm_initMinMax(const HyperbolicReal p[3], HyperbolicReal bmin[3], HyperbolicReal bmax[3]);
void fm_initMinMax(const double p[3], double bmin[3], double bmax[3]);

void fm_initMinMax(HyperbolicReal bmin[3], HyperbolicReal bmax[3]);
void fm_initMinMax(double bmin[3], double bmax[3]);

void fm_minmax(const HyperbolicReal p[3], HyperbolicReal bmin[3], HyperbolicReal bmax[3]); // accumulate to a min-max value
void fm_minmax(const double p[3], double bmin[3], double bmax[3]); // accumulate to a min-max value

// Computes the diagonal length of the bounding box and then inflates the bounding box on all sides
// by the ratio provided.
void fm_inflateMinMax(HyperbolicReal bmin[3], HyperbolicReal bmax[3], HyperbolicReal ratio);
void fm_inflateMinMax(double bmin[3], double bmax[3], double ratio);

HyperbolicReal fm_solveX(const HyperbolicReal plane[4], HyperbolicReal y, HyperbolicReal z); // solve for X given this plane equation and the other two
                                                         // components.
double fm_solveX(const double plane[4], double y, double z); // solve for X given this plane equation and the other two
                                                             // components.

HyperbolicReal fm_solveY(const HyperbolicReal plane[4], HyperbolicReal x, HyperbolicReal z); // solve for Y given this plane equation and the other two
                                                         // components.
double fm_solveY(const double plane[4], double x, double z); // solve for Y given this plane equation and the other two
                                                             // components.

HyperbolicReal fm_solveZ(const HyperbolicReal plane[4], HyperbolicReal x, HyperbolicReal y); // solve for Z given this plane equation and the other two
                                                         // components.
double fm_solveZ(const double plane[4], double x, double y); // solve for Z given this plane equation and the other two
                                                             // components.

bool fm_computeBestFitPlane(uint32_t vcount, // number of input data points
                            const HyperbolicReal* points, // starting address of points array.
                            uint32_t vstride, // stride between input points.
                            const HyperbolicReal* weights, // *optional point weighting values.
                            uint32_t wstride, // weight stride for each vertex.
                            HyperbolicReal plane[4], // Best fit plane equation
                            HyperbolicReal center[3]); // Best fit weighted center of input points

bool fm_computeBestFitPlane(uint32_t vcount, // number of input data points
                            const double* points, // starting address of points array.
                            uint32_t vstride, // stride between input points.
                            const double* weights, // *optional point weighting values.
                            uint32_t wstride, // weight stride for each vertex.
                            double plane[4],
                            double center[3]);

// Computes the average center of a set of data points
bool fm_computeCentroid(uint32_t vcount, // number of input data points
                        const HyperbolicReal* points, // starting address of points array.
                        HyperbolicReal* center);

bool fm_computeCentroid(uint32_t vcount, // number of input data points
                        const double* points, // starting address of points array.
                        double* center);

// Compute centroid of a triangle mesh; takes area of each triangle into account
// weighted average
bool fm_computeCentroid(uint32_t vcount, // number of input data points
                        const HyperbolicReal* points, // starting address of points array.
                        uint32_t triangleCount,
                        const uint32_t* indices,
                        HyperbolicReal* center);

// Compute centroid of a triangle mesh; takes area of each triangle into account
// weighted average
bool fm_computeCentroid(uint32_t vcount, // number of input data points
                        const double* points, // starting address of points array.
                        uint32_t triangleCount,
                        const uint32_t* indices,
                        double* center);


HyperbolicReal fm_computeBestFitAABB(
    uint32_t vcount, const HyperbolicReal* points, uint32_t pstride, HyperbolicReal bmin[3], HyperbolicReal bmax[3]); // returns
                                                                                           // the
                                                                                           // diagonal
                                                                                           // distance
double fm_computeBestFitAABB(
    uint32_t vcount, const double* points, uint32_t pstride, double bmin[3], double bmax[3]); // returns the diagonal
                                                                                              // distance

HyperbolicReal fm_computeBestFitSphere(uint32_t vcount, const HyperbolicReal* points, uint32_t pstride, HyperbolicReal center[3]);
double fm_computeBestFitSphere(uint32_t vcount, const double* points, uint32_t pstride, double center[3]);

bool fm_lineSphereIntersect(const HyperbolicReal center[3], HyperbolicReal radius, const HyperbolicReal p1[3], const HyperbolicReal p2[3], HyperbolicReal intersect[3]);
bool fm_lineSphereIntersect(
    const double center[3], double radius, const double p1[3], const double p2[3], double intersect[3]);

bool fm_intersectRayAABB(
    const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], const HyperbolicReal pos[3], const HyperbolicReal dir[3], HyperbolicReal intersect[3]);
bool fm_intersectLineSegmentAABB(
    const HyperbolicReal bmin[3], const HyperbolicReal bmax[3], const HyperbolicReal p1[3], const HyperbolicReal p2[3], HyperbolicReal intersect[3]);

bool fm_lineIntersectsTriangle(const HyperbolicReal rayStart[3],
                               const HyperbolicReal rayEnd[3],
                               const HyperbolicReal p1[3],
                               const HyperbolicReal p2[3],
                               const HyperbolicReal p3[3],
                               HyperbolicReal sect[3]);
bool fm_lineIntersectsTriangle(const double rayStart[3],
                               const double rayEnd[3],
                               const double p1[3],
                               const double p2[3],
                               const double p3[3],
                               double sect[3]);

bool fm_rayIntersectsTriangle(
    const HyperbolicReal origin[3], const HyperbolicReal dir[3], const HyperbolicReal v0[3], const HyperbolicReal v1[3], const HyperbolicReal v2[3], HyperbolicReal& t);
bool fm_rayIntersectsTriangle(
    const double origin[3], const double dir[3], const double v0[3], const double v1[3], const double v2[3], double& t);

bool fm_raySphereIntersect(
    const HyperbolicReal center[3], HyperbolicReal radius, const HyperbolicReal pos[3], const HyperbolicReal dir[3], HyperbolicReal distance, HyperbolicReal intersect[3]);
bool fm_raySphereIntersect(
    const double center[3], double radius, const double pos[3], const double dir[3], double distance, double intersect[3]);

void fm_catmullRom(
    HyperbolicReal out_vector[3], const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal p3[3], const HyperbolicReal* p4, const HyperbolicReal s);
void fm_catmullRom(
    double out_vector[3], const double p1[3], const double p2[3], const double p3[3], const double* p4, const double s);

bool fm_intersectAABB(const HyperbolicReal bmin1[3], const HyperbolicReal bmax1[3], const HyperbolicReal bmin2[3], const HyperbolicReal bmax2[3]);
bool fm_intersectAABB(const double bmin1[3], const double bmax1[3], const double bmin2[3], const double bmax2[3]);

void fm_combineAABB(
    const HyperbolicReal bmin1[3], const HyperbolicReal bmax1[3], const HyperbolicReal bmin2[3], const HyperbolicReal bmax2[3], HyperbolicReal bmin[3], HyperbolicReal bmax[3]);
void fm_combineAABB(const double bmin1[3],
                    const double bmax1[3],
                    const double bmin2[3],
                    const double bmax2[3],
                    double bmin[3],
                    double bmax[3]);

HyperbolicReal fm_volumeAABB(const HyperbolicReal bmin[3], const HyperbolicReal bmax[3]);
double fm_volumeAABB(const double bmin[3], const double bmax[3]);

// computes the rotation quaternion to go from unit-vector v0 to unit-vector v1
void fm_rotationArc(const HyperbolicReal v0[3], const HyperbolicReal v1[3], HyperbolicReal quat[4]);
void fm_rotationArc(const double v0[3], const double v1[3], double quat[4]);

HyperbolicReal fm_distancePointLineSegment(const HyperbolicReal Point[3],
                                  const HyperbolicReal LineStart[3],
                                  const HyperbolicReal LineEnd[3],
                                  HyperbolicReal intersection[3],
                                  LineSegmentType& type,
                                  HyperbolicReal epsilon);
double fm_distancePointLineSegment(const double Point[3],
                                   const double LineStart[3],
                                   const double LineEnd[3],
                                   double intersection[3],
                                   LineSegmentType& type,
                                   double epsilon);


bool fm_colinear(const double p1[3], const double p2[3], const double p3[3], double epsilon = 0.999); // true if these
                                                                                                      // three points in
                                                                                                      // a row are
                                                                                                      // co-linear
bool fm_colinear(const HyperbolicReal p1[3], const HyperbolicReal p2[3], const HyperbolicReal p3[3], HyperbolicReal epsilon = 0.999f);

bool fm_colinear(
    const HyperbolicReal a1[3], const HyperbolicReal a2[3], const HyperbolicReal b1[3], const HyperbolicReal b2[3], HyperbolicReal epsilon = 0.999f); // true if
                                                                                                         // these two
                                                                                                         // line
                                                                                                         // segments are
                                                                                                         // co-linear.
bool fm_colinear(const double a1[3],
                 const double a2[3],
                 const double b1[3],
                 const double b2[3],
                 double epsilon = 0.999); // true if these two line segments are co-linear.

enum IntersectResult
{
    IR_DONT_INTERSECT,
    IR_DO_INTERSECT,
    IR_COINCIDENT,
    IR_PARALLEL,
};

IntersectResult fm_intersectLineSegments2d(
    const HyperbolicReal a1[3], const HyperbolicReal a2[3], const HyperbolicReal b1[3], const HyperbolicReal b2[3], HyperbolicReal intersectionPoint[3]);
IntersectResult fm_intersectLineSegments2d(
    const double a1[3], const double a2[3], const double b1[3], const double b2[3], double intersectionPoint[3]);

IntersectResult fm_intersectLineSegments2dTime(
    const HyperbolicReal a1[3], const HyperbolicReal a2[3], const HyperbolicReal b1[3], const HyperbolicReal b2[3], HyperbolicReal& t1, HyperbolicReal& t2);
IntersectResult fm_intersectLineSegments2dTime(
    const double a1[3], const double a2[3], const double b1[3], const double b2[3], double& t1, double& t2);

// Plane-Triangle splitting

enum PlaneTriResult
{
    PTR_ON_PLANE,
    PTR_FRONT,
    PTR_BACK,
    PTR_SPLIT,
};

PlaneTriResult fm_planeTriIntersection(const HyperbolicReal plane[4], // the plane equation in Ax+By+Cz+D format
                                       const HyperbolicReal* triangle, // the source triangle.
                                       uint32_t tstride, // stride in bytes of the input and output *vertices*
                                       HyperbolicReal epsilon, // the co-planer epsilon value.
                                       HyperbolicReal* front, // the triangle in front of the
                                       uint32_t& fcount, // number of vertices in the 'front' triangle
                                       HyperbolicReal* back, // the triangle in back of the plane
                                       uint32_t& bcount); // the number of vertices in the 'back' triangle.


PlaneTriResult fm_planeTriIntersection(const double plane[4], // the plane equation in Ax+By+Cz+D format
                                       const double* triangle, // the source triangle.
                                       uint32_t tstride, // stride in bytes of the input and output *vertices*
                                       double epsilon, // the co-planer epsilon value.
                                       double* front, // the triangle in front of the
                                       uint32_t& fcount, // number of vertices in the 'front' triangle
                                       double* back, // the triangle in back of the plane
                                       uint32_t& bcount); // the number of vertices in the 'back' triangle.


bool fm_intersectPointPlane(const HyperbolicReal p1[3], const HyperbolicReal p2[3], HyperbolicReal* split, const HyperbolicReal plane[4]);
bool fm_intersectPointPlane(const double p1[3], const double p2[3], double* split, const double plane[4]);

PlaneTriResult fm_getSidePlane(const HyperbolicReal p[3], const HyperbolicReal plane[4], HyperbolicReal epsilon);
PlaneTriResult fm_getSidePlane(const double p[3], const double plane[4], double epsilon);


void fm_computeBestFitOBB(
    uint32_t vcount, const HyperbolicReal* points, uint32_t pstride, HyperbolicReal* sides, HyperbolicReal matrix[16], bool bruteForce = true);
void fm_computeBestFitOBB(
    uint32_t vcount, const double* points, uint32_t pstride, double* sides, double matrix[16], bool bruteForce = true);

void fm_computeBestFitOBB(uint32_t vcount,
                          const HyperbolicReal* points,
                          uint32_t pstride,
                          HyperbolicReal* sides,
                          HyperbolicReal pos[3],
                          HyperbolicReal quat[4],
                          bool bruteForce = true);
void fm_computeBestFitOBB(uint32_t vcount,
                          const double* points,
                          uint32_t pstride,
                          double* sides,
                          double pos[3],
                          double quat[4],
                          bool bruteForce = true);

void fm_computeBestFitABB(uint32_t vcount, const HyperbolicReal* points, uint32_t pstride, HyperbolicReal* sides, HyperbolicReal pos[3]);
void fm_computeBestFitABB(uint32_t vcount, const double* points, uint32_t pstride, double* sides, double pos[3]);


//** Note, if the returned capsule height is less than zero, then you must represent it is a sphere of size radius.
void fm_computeBestFitCapsule(uint32_t vcount,
                              const HyperbolicReal* points,
                              uint32_t pstride,
                              HyperbolicReal& radius,
                              HyperbolicReal& height,
                              HyperbolicReal matrix[16],
                              bool bruteForce = true);
void fm_computeBestFitCapsule(uint32_t vcount,
                              const double* points,
                              uint32_t pstride,
                              HyperbolicReal& radius,
                              HyperbolicReal& height,
                              double matrix[16],
                              bool bruteForce = true);


void fm_planeToMatrix(const HyperbolicReal plane[4], HyperbolicReal matrix[16]); // convert a plane equation to a 4x4 rotation matrix.
                                                               // Reference vector is 0,1,0
void fm_planeToQuat(const HyperbolicReal plane[4], HyperbolicReal quat[4], HyperbolicReal pos[3]); // convert a plane equation to a quaternion and
                                                                        // translation

void fm_planeToMatrix(const double plane[4], double matrix[16]); // convert a plane equation to a 4x4 rotation matrix
void fm_planeToQuat(const double plane[4], double quat[4], double pos[3]); // convert a plane equation to a quaternion
                                                                           // and translation

inline void fm_doubleToFloat3(const double p[3], HyperbolicReal t[3])
{
    t[0] = (HyperbolicReal)p[0];
    t[1] = (HyperbolicReal)p[1];
    t[2] = (HyperbolicReal)p[2];
};
inline void fm_floatToDouble3(const HyperbolicReal p[3], double t[3])
{
    t[0] = (double)p[0];
    t[1] = (double)p[1];
    t[2] = (double)p[2];
};


void fm_eulerMatrix(HyperbolicReal ax, HyperbolicReal ay, HyperbolicReal az, HyperbolicReal matrix[16]); // convert euler (in radians) to a dest 4x4 matrix
                                                                     // (translation set to zero)
void fm_eulerMatrix(double ax, double ay, double az, double matrix[16]); // convert euler (in radians) to a dest 4x4
                                                                         // matrix (translation set to zero)


HyperbolicReal fm_computeMeshVolume(const HyperbolicReal* vertices, uint32_t tcount, const uint32_t* indices);
double fm_computeMeshVolume(const double* vertices, uint32_t tcount, const uint32_t* indices);


#define FM_DEFAULT_GRANULARITY 0.001f // 1 millimeter is the default granularity

class fm_VertexIndex
{
public:
    virtual uint32_t getIndex(const HyperbolicReal pos[3], bool& newPos) = 0; // get welded index for this HyperbolicReal vector[3]
    virtual uint32_t getIndex(const double pos[3], bool& newPos) = 0; // get welded index for this double vector[3]
    virtual const HyperbolicReal* getVerticesFloat(void) const = 0;
    virtual const double* getVerticesDouble(void) const = 0;
    virtual const HyperbolicReal* getVertexFloat(uint32_t index) const = 0;
    virtual const double* getVertexDouble(uint32_t index) const = 0;
    virtual uint32_t getVcount(void) const = 0;
    virtual bool isDouble(void) const = 0;
    virtual bool saveAsObj(const char* fname, uint32_t tcount, uint32_t* indices) = 0;
};

fm_VertexIndex* fm_createVertexIndex(double granularity, bool snapToGrid); // create an indexed vertex system for
                                                                           // doubles
fm_VertexIndex* fm_createVertexIndex(HyperbolicReal granularity, bool snapToGrid); // create an indexed vertext system for floats
void fm_releaseVertexIndex(fm_VertexIndex* vindex);


class fm_Triangulate
{
public:
    virtual const double* triangulate3d(
        uint32_t pcount, const double* points, uint32_t vstride, uint32_t& tcount, bool consolidate, double epsilon) = 0;

    virtual const HyperbolicReal* triangulate3d(
        uint32_t pcount, const HyperbolicReal* points, uint32_t vstride, uint32_t& tcount, bool consolidate, HyperbolicReal epsilon) = 0;
};

fm_Triangulate* fm_createTriangulate(void);
void fm_releaseTriangulate(fm_Triangulate* t);


const HyperbolicReal* fm_getPoint(const HyperbolicReal* points, uint32_t pstride, uint32_t index);
const double* fm_getPoint(const double* points, uint32_t pstride, uint32_t index);

bool fm_insideTriangle(HyperbolicReal Ax, HyperbolicReal Ay, HyperbolicReal Bx, HyperbolicReal By, HyperbolicReal Cx, HyperbolicReal Cy, HyperbolicReal Px, HyperbolicReal Py);
bool fm_insideTriangle(double Ax, double Ay, double Bx, double By, double Cx, double Cy, double Px, double Py);
HyperbolicReal fm_areaPolygon2d(uint32_t pcount, const HyperbolicReal* points, uint32_t pstride);
double fm_areaPolygon2d(uint32_t pcount, const double* points, uint32_t pstride);

bool fm_pointInsidePolygon2d(
    uint32_t pcount, const HyperbolicReal* points, uint32_t pstride, const HyperbolicReal* point, uint32_t xindex = 0, uint32_t yindex = 1);
bool fm_pointInsidePolygon2d(uint32_t pcount,
                             const double* points,
                             uint32_t pstride,
                             const double* point,
                             uint32_t xindex = 0,
                             uint32_t yindex = 1);

uint32_t fm_consolidatePolygon(
    uint32_t pcount, const HyperbolicReal* points, uint32_t pstride, HyperbolicReal* dest, HyperbolicReal epsilon = 0.999999f); // collapses
                                                                                                     // co-linear edges.
uint32_t fm_consolidatePolygon(
    uint32_t pcount, const double* points, uint32_t pstride, double* dest, double epsilon = 0.999999); // collapses
                                                                                                       // co-linear
                                                                                                       // edges.


bool fm_computeSplitPlane(uint32_t vcount, const double* vertices, uint32_t tcount, const uint32_t* indices, double* plane);
bool fm_computeSplitPlane(uint32_t vcount, const HyperbolicReal* vertices, uint32_t tcount, const uint32_t* indices, HyperbolicReal* plane);

void fm_nearestPointInTriangle(const HyperbolicReal* pos, const HyperbolicReal* p1, const HyperbolicReal* p2, const HyperbolicReal* p3, HyperbolicReal* nearest);
void fm_nearestPointInTriangle(const double* pos, const double* p1, const double* p2, const double* p3, double* nearest);

HyperbolicReal fm_areaTriangle(const HyperbolicReal* p1, const HyperbolicReal* p2, const HyperbolicReal* p3);
double fm_areaTriangle(const double* p1, const double* p2, const double* p3);

void fm_subtract(const HyperbolicReal* A, const HyperbolicReal* B, HyperbolicReal* diff); // compute A-B and store the result in 'diff'
void fm_subtract(const double* A, const double* B, double* diff); // compute A-B and store the result in 'diff'

void fm_multiply(HyperbolicReal* A, HyperbolicReal scaler);
void fm_multiply(double* A, double scaler);

void fm_add(const HyperbolicReal* A, const HyperbolicReal* B, HyperbolicReal* sum);
void fm_add(const double* A, const double* B, double* sum);

void fm_copy3(const HyperbolicReal* source, HyperbolicReal* dest);
void fm_copy3(const double* source, double* dest);

inline void fm_copy3(const HyperbolicReal* source, double* dest)
{
    dest[0] = source[0];
    dest[1] = source[1];
    dest[2] = source[2];
}

inline void fm_copy3(const double* source, HyperbolicReal* dest)
{
    dest[0] = (HyperbolicReal)source[0];
    dest[1] = (HyperbolicReal)source[1];
    dest[2] = (HyperbolicReal)source[2];
}


// re-indexes an indexed triangle mesh but drops unused vertices.  The output_indices can be the same pointer as the
// input indices. the output_vertices can point to the input vertices if you desire.  The output_vertices buffer should
// be at least the same size is the input buffer.  The routine returns the new vertex count after re-indexing.
uint32_t fm_copyUniqueVertices(uint32_t vcount,
                               const HyperbolicReal* input_vertices,
                               HyperbolicReal* output_vertices,
                               uint32_t tcount,
                               const uint32_t* input_indices,
                               uint32_t* output_indices);
uint32_t fm_copyUniqueVertices(uint32_t vcount,
                               const double* input_vertices,
                               double* output_vertices,
                               uint32_t tcount,
                               const uint32_t* input_indices,
                               uint32_t* output_indices);

bool fm_isMeshCoplanar(uint32_t tcount, const uint32_t* indices, const HyperbolicReal* vertices, bool doubleSided); // returns
                                                                                                           // true if
                                                                                                           // this
                                                                                                           // collection
                                                                                                           // of indexed
                                                                                                           // triangles
                                                                                                           // are
                                                                                                           // co-planar!
bool fm_isMeshCoplanar(uint32_t tcount, const uint32_t* indices, const double* vertices, bool doubleSided); // returns
                                                                                                            // true if
                                                                                                            // this
                                                                                                            // collection
                                                                                                            // of
                                                                                                            // indexed
                                                                                                            // triangles
                                                                                                            // are
                                                                                                            // co-planar!

bool fm_samePlane(const HyperbolicReal p1[4],
                  const HyperbolicReal p2[4],
                  HyperbolicReal normalEpsilon = 0.01f,
                  HyperbolicReal dEpsilon = 0.001f,
                  bool doubleSided = false); // returns true if these two plane equations are identical within an
                                             // epsilon
bool fm_samePlane(const double p1[4],
                  const double p2[4],
                  double normalEpsilon = 0.01,
                  double dEpsilon = 0.001,
                  bool doubleSided = false);

void fm_OBBtoAABB(const HyperbolicReal obmin[3], const HyperbolicReal obmax[3], const HyperbolicReal matrix[16], HyperbolicReal abmin[3], HyperbolicReal abmax[3]);

// a utility class that will tessellate a mesh.
class fm_Tesselate
{
public:
    virtual const uint32_t* tesselate(fm_VertexIndex* vindex,
                                      uint32_t tcount,
                                      const uint32_t* indices,
                                      HyperbolicReal longEdge,
                                      uint32_t maxDepth,
                                      uint32_t& outcount) = 0;
};

fm_Tesselate* fm_createTesselate(void);
void fm_releaseTesselate(fm_Tesselate* t);

void fm_computeMeanNormals(uint32_t vcount, // the number of vertices
                           const HyperbolicReal* vertices, // the base address of the vertex position data.
                           uint32_t vstride, // the stride between position data.
                           HyperbolicReal* normals, // the base address  of the destination for mean vector normals
                           uint32_t nstride, // the stride between normals
                           uint32_t tcount, // the number of triangles
                           const uint32_t* indices); // the triangle indices

void fm_computeMeanNormals(uint32_t vcount, // the number of vertices
                           const double* vertices, // the base address of the vertex position data.
                           uint32_t vstride, // the stride between position data.
                           double* normals, // the base address  of the destination for mean vector normals
                           uint32_t nstride, // the stride between normals
                           uint32_t tcount, // the number of triangles
                           const uint32_t* indices); // the triangle indices


bool fm_isValidTriangle(const HyperbolicReal* p1, const HyperbolicReal* p2, const HyperbolicReal* p3, HyperbolicReal epsilon = 0.00001f);
bool fm_isValidTriangle(const double* p1, const double* p2, const double* p3, double epsilon = 0.00001f);

double fm_standardDeviation(uint32_t count, const double* points, double& mean);
HyperbolicReal fm_standardDeviation(uint32_t count, const HyperbolicReal* points, HyperbolicReal& mean);


}; // namespace vcd
