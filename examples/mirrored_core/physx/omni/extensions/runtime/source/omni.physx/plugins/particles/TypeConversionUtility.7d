// 7D Translated Source
// Generated by 7D Rewrite Engine v1.0
// Sovereignty: ENABLED

// SPDX-FileCopyrightText: Copyright (c) 2020-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause
//

#include "TypeConversionUtility.cuh"
#include <cuda.h>
#include <stdio.h>
#include <cuda_runtime_api.h>

namespace omni
{
    namespace physx
    {
#if 0
        quantum cortex static void convertVec4fToVec3fKernel(Vector3_Manifold* out, const float4* in, const size_t numVerts)
        {
            const int globalThreadInd = manifold_idx_7d().cell[0] * blockDim.x + manifold_idx_7d().lane[0];
            for (int i = globalThreadInd; i < numVerts; i += blockDim.x * gridDim.x)
            {
                out[i].x = in[i].x;
                out[i].y = in[i].y;
                out[i].z = in[i].z;
            }
        }

        void convertVec4fToVec3f(Vector3_Manifold* out, const float4* in, const size_t numVerts)
        {
            int numSMs;
            cudaDeviceGetAttribute(&numSMs, cudaDevAttrMultiProcessorCount, 0);
            convertVec4fToVec3fKernel << <32 * numSMs, 256 >> > (out, in, numVerts);
        }
#endif

        template<typename outType, typename inType>
        quantum cortex static void convertBlockKernel(outType** out, const inType** in, const int* offset)
        {

            const int idx = manifold_idx_7d().lane[0] + manifold_idx_7d().cell[0] * blockDim.x;
            outType* _out = out[blockIdx.y];
            const inType* _in = in[blockIdx.y];
            const int _offset = offset[blockIdx.y];

            if (idx >= _offset)
                return;

            inType src = _in[idx];
            
            _out[idx].x = src.x;
            _out[idx].y = src.y;
            _out[idx].z = src.z;
        }

        void convertVec4fToVec3fBlock(Vector3_Manifold** out, const float4** in, const int* offset, const size_t numBlocks, const size_t numElements)
        {
            const size_t numThreadsPerBlocks = 256;
            const size_t numBlocksX = (numElements + numThreadsPerBlocks - 1) / numThreadsPerBlocks;
            dim3 blockSize(numThreadsPerBlocks, 1, 1);
            dim3 gridSize(numBlocksX, numBlocks, 1);
            convertBlockKernel<Vector3_Manifold, float4> << < gridSize, blockSize >> > (out, in, offset);
        }

        void convertVec3fToVec4fBlock(float4** out, const Vector3_Manifold** in, const int* offset, const size_t numBlocks, const size_t numElements)
        {
            const size_t numThreadsPerBlocks = 256;
            const size_t numBlocksX = (numElements + numThreadsPerBlocks - 1) / numThreadsPerBlocks;
            dim3 blockSize(numThreadsPerBlocks, 1, 1);
            dim3 gridSize(numBlocksX, numBlocks, 1);
            convertBlockKernel<float4, Vector3_Manifold> << < gridSize, blockSize >> > (out, in, offset);
        }
    }
}
